{
    "processed": [
        {
            "filename": "Android_Security_Checklist.md",
            "total_characters": 6155,
            "total_chunks": 4,
            "chunks": [
                "# Android 보안 체크리스트\n\n## 개요\n\n본 체크리스트는 Android 앱 개발 및 배포 시 필수적으로 확인해야 할 보안 항목들을 단계별로 정리한 문서입니다. Kotlin, Compose, Hilt, Room, Clean Architecture, MVI, Flow 기반 앱에 특화된 보안 검증 항목들을 포함합니다.\n\n---\n\n## 🔐 인증 및 세션 관리\n\n### ✅ 사용자 인증\n- [ ] * *생체 인증 구현**: 지문/얼굴 인식 통합 완료\n- [ ] * *EncryptedSharedPreferences**: 민감정보는 암호화된 저장소 사용\n- [ ] * *JWT 토큰 검증**: 토큰 만료 시간 및 무결성 검증\n- [ ] **자동 로그아웃**: 비활성 시간 기반 자동 로그아웃\n- [ ] * *다중 기기 관리**: 동시 로그인 세션 수 제한\n\n### ✅ 세션 보안\n- [ ] * *세션 타임아웃**: 15-30분 비활성 시 세션 만료\n- [ ] **토큰 갱신 메커니즘**: Refresh token 자동 갱신\n- [ ] **완전한 로그아웃**: 모든 인증 정보 완전 삭제\n- [ ] * *백그라운드 보안**: 앱 전환 시 민감 화면 가림\n\n---\n\n## 🌐 네트워크 통신 보안\n\n### ✅ HTTPS 및 인증서\n- [ ] * *Network Security Config**: 명시적 네트워크 보안 설정\n- [ ] * *Certificate Pinning**: OkHttp로 인증서 고정\n- [ ] * *TLS 1.2+ 강제**: 구버전 SSL/TLS 차단\n- [ ] * *Cleartext 트래픽 금지**: `usesCleartextTraffic=\"false\"`\n\n### ✅ API 보안\n- [ ] * *API 키 보안**: BuildConfig 또는 NDK로 API 키 보호\n- [ ] **요청/응답 암호화**: 민감 데이터 추가 암호화\n- [ ] * *HTTP 헤더 보안**: 적절한 보안 헤더 설정\n- [ ] * *Rate Limiting* *: API 호출 빈도 제한\n\n---\n\n## 💾 데이터 저장 보안\n\n### ✅ Room 데이터베이스\n- [ ] **SQLCipher 암호화**: Room DB 암호화 적용\n- [ ] **동적 암호화 키**: 하드코딩된 키 사용 금지\n- [ ] * *SQL 인젝션 방지**: 파라미터화된 쿼리만 사용\n- [ ] * *데이터베이스 백업 제한**: 백업에서 DB 제외\n\n### ✅ SharedPreferences\n- [ ] * *EncryptedSharedPreferences**: 암호화된 환경설정 사용\n- [ ] * *민감정보 저장 금지**: 일반 SharedPreferences에 민감정보 금지\n- [ ] **키 관리**: MasterKey를 통한 키 관리\n- [ ] **앱 삭제 시 정리**: 앱 제거 시 데이터 완전 삭제\n\n### ✅ 외부 저장소\n- [ ] * *내부 저장소 우선**: 가능한 내부 저장소 사용\n- [ ] * *파일 암호화**: 외부 저장 시 파일 암호화\n- [ ] * *권한 최소화**: 필요 최소한의 저장소 권한\n- [ ] * *임시 파일 관리**: 사용 후 임시 파일 자동 삭제\n\n---\n\n## 🛡️ 코드 보호 및 난독화\n\n### ✅ ProGuard/R8 설정\n- [ ] * *코드 난독화**: Release 빌드에서 난독화 활성화\n- [ ] **리소스 축소**: 사용하지 않는 리소스 제거\n- [ ] * *문자열 암호화**: 중요 문자열 난독화\n- [ ] **클래스/메소드명 난독화**: 식별 가능한 이름 변경\n\n### ✅ NDK 보안\n- [ ] **중요 로직 네이티브화**: 핵심 로직을 C/C++로 이동\n- [ ] * *네이티브 라이브러리 난독화**: .so 파일 난독화\n- [ ] * *JNI 보안**: JNI 인터페이스 최소화\n- [ ] **동적 로딩**: 런타임 네이티브 라이브러리 로딩\n\n### ✅ 런타임 보호\n- [ ] **안티 디버깅**: 디버거 연결 탐지 및 차단\n- [ ] * *루트 탐지**: 루팅 기기에서 실행 제한\n- [ ] *",
                "*후킹 방지**: Frida, Xposed 등 탐지\n- [ ] **앱 무결성 검사**: APK 서명 및 해시 검증\n\n---\n\n## ⚠️ 위험 요소 탐지\n\n### ✅ 기기 보안 상태\n- [ ] * *루팅 탐지**: \n  - [ ] Superuser 앱 존재 확인\n  - [ ] 루트 관련 바이너리 파일 확인\n  - [ ] Build.TAGS 값 확인\n  - [ ] su 명령어 실행 가능 여부 확인\n\n### ✅ 앱 환경 검증\n- [ ] * *에뮬레이터 탐지**: 에뮬레이터 환경 실행 차단\n- [ ] * *디버그 모드 탐지**: 디버그 빌드에서만 디버그 기능 활성화\n- [ ] **개발자 옵션 탐지**: 개발자 옵션 활성화 상태 확인\n- [ ] * *ADB 연결 탐지**: ADB 디버깅 연결 상태 확인\n\n### ✅ 런타임 무결성\n- [ ] **앱 서명 검증**: 설치된 앱의 서명 확인\n- [ ] * *패키지 위변조 탐지**: APK 해시 값 검증\n- [ ] * *메모리 덤프 방지**: 메모리 덤프 시도 탐지\n- [ ] * *코드 인젝션 탐지**: 런타임 코드 변조 탐지\n\n---\n\n## 📱 Android 플랫폼 보안\n\n### ✅ Manifest 보안 설정\n- [ ] * *권한 최소화**: 필요한 권한만 요청\n- [ ] * *백업 제한**: `android:allowBackup=\"false\"`\n- [ ] **디버깅 비활성화**: `android:debuggable=\"false\"`\n- [ ] * *exported 명시**: 모든 컴포넌트에 exported 명시\n\n### ✅ Activity 보안\n- [ ] * *Intent 필터 검증**: 수신 Intent 데이터 검증\n- [ ] * *Task Affinity**: 민감한 Activity의 태스크 분리\n- [ ] * *스크린샷 방지**: `FLAG_SECURE` 플래그 설정\n- [ ] **백 스택 관리**: 민감 정보 포함 Activity 백 스택 관리\n\n### ✅ Service 보안\n- [ ] * *Service 접근 제어**: 필요한 경우에만 exported 설정\n- [ ] **권한 기반 접근**: 커스텀 권한으로 Service 보호\n- [ ] * *바인딩 보안**: Binder 인터페이스 보안 검증\n- [ ] * *생명주기 관리**: 불필요한 Service 실행 방지\n\n### ✅ Broadcast Receiver\n- [ ] **동적 등록 우선**: 가능한 동적 리시버 등록\n- [ ] **권한 기반 필터링**: 송신자 권한 검증\n- [ ] * *Intent 데이터 검증**: 수신 데이터 무결성 확인\n- [ ] **로컬 브로드캐스트**: 앱 내부 통신은 LocalBroadcastManager 사용\n\n### ✅ Content Provider\n- [ ] * *접근 권한 설정**: 읽기/쓰기 권한 분리\n- [ ] * *URI 검증**: 요청 URI 패턴 검증\n- [ ] * *SQL 인젝션 방지**: 파라미터화된 쿼리 사용\n- [ ] * *경로 순회 공격 방지**: 파일 경로 검증\n\n---\n\n## 🔧 Build 및 환경 설정\n\n### ✅ Gradle 보안 설정\n- [ ] * *BuildConfig 분리**: 개발/운영 환경 분리\n- [ ] * *서명 키 보안**: 키스토어 파일 보안 관리\n- [ ] * *ProGuard 설정**: 적절한 난독화 규칙 적용\n- [ ] * *의존성 검증**: 사용 라이브러리 보안 취약점 확인\n\n### ✅ 코드 품질 관리\n- [ ] * *정적 분석**: SonarQube, SpotBugs 등 정적 분석 도구 사용\n- [ ] **보안 린트**: Android Lint 보안 규칙 적용\n- [ ] * *의존성 스캔**: OWASP Dependency Check 실행\n- [ ] * *코드 리뷰**: 보안 관점의 코드 리뷰 수행\n\n---\n\n## 📊 모니터링 및 로깅\n\n### ✅ 보안 로깅\n- [ ] * *인증 이벤트**: 로그인/로그아웃 이벤트 로깅\n- [ ] **보안 위협 감지**: 루팅, 디버깅 시도 등 로깅\n- [ ] *",
                "*민감정보 필터링**: 로그에서 민감정보 제거\n- [ ] **로그 레벨 관리**: 운영 환경에서 로그 레벨 제한\n\n### ✅ 크래시 및 에러 처리\n- [ ] **크래시 리포팅**: Firebase Crashlytics 등 크래시 수집\n- [ ] **보안 예외 처리**: 보안 관련 예외 별도 처리\n- [ ] **에러 정보 최소화**: 에러 메시지에서 시스템 정보 노출 방지\n- [ ] * *자동 복구**: 보안 위협 탐지 시 자동 복구 메커니즘\n\n---\n\n## 🧪 보안 테스트\n\n### ✅ 정적 분석 테스트\n- [ ] * *코드 스캔**: SonarQube, Checkmarx 등으로 코드 스캔\n- [ ] * *의존성 취약점**: OWASP Dependency Check 실행\n- [ ] * *Android Lint**: 보안 관련 Lint 규칙 검사\n- [ ] * *설정 검토**: 보안 설정 항목 검증\n\n### ✅ 동적 분석 테스트\n- [ ] * *런타임 테스트**: 실제 기기에서 보안 기능 검증\n- [ ] * *네트워크 분석**: Burp Suite, OWASP ZAP으로 트래픽 분석\n- [ ] * *메모리 분석**: 메모리 덤프를 통한 민감정보 노출 확인\n- [ ] * *Intent 퍼징**: Intent 데이터 퍼징 테스트\n\n### ✅ 침투 테스트\n- [ ] * *APK 분석**: APKTool, JADX로 디컴파일 테스트\n- [ ] * *런타임 조작**: Frida로 런타임 조작 테스트\n- [ ] * *후킹 테스트**: Xposed 모듈을 통한 후킹 테스트\n- [ ] * *우회 시도**: 보안 기능 우회 시도 테스트\n\n---\n\n## 📋 배포 전 최종 점검\n\n### ✅ Google Play 배포 준비\n- [ ] **앱 번들 최적화**: Android App Bundle 사용\n- [ ] * *개인정보 처리방침**: 개인정보 수집/이용 고지\n- [ ] **권한 사용 설명**: 각 권한의 사용 목적 명시\n- [ ] * *타겟 SDK**: 최신 타겟 SDK 버전 적용\n\n### ✅ 보안 검증 완료\n- [ ] * *모든 체크리스트 확인**: 상기 모든 항목 점검 완료\n- [ ] **보안 테스트 수행**: 정적/동적/침투 테스트 완료\n- [ ] **제3자 보안 검증**: 외부 보안 업체 검증 완료\n- [ ] * *문서화**: 보안 관련 문서 업데이트\n\n---\n\n## 🚨 긴급 대응 절차\n\n### ✅ 보안 사고 대응\n- [ ] **사고 대응 팀**: 보안 사고 대응 조직 구성\n- [ ] **대응 절차 수립**: 단계별 대응 절차 문서화\n- [ ] * *커뮤니케이션 계획**: 내외부 커뮤니케이션 방안\n- [ ] **복구 계획**: 서비스 복구 및 재개 절차\n\n### ✅ 업데이트 및 패치\n- [ ] * *긴급 패치**: 보안 취약점 발견 시 긴급 패치 절차\n- [ ] * *업데이트 강제**: 중요 보안 업데이트 시 강제 업데이트\n- [ ] * *롤백 계획**: 문제 발생 시 이전 버전 롤백 절차\n- [ ] * *사용자 공지**: 보안 업데이트 관련 사용자 공지\n\n---\n\n## 🔍 지속적인 보안 관리\n\n### ✅ 보안 모니터링\n- [ ] * *보안 지표**: 보안 관련 KPI 설정 및 모니터링\n- [ ] **위협 인텔리전스**: 최신 보안 위협 정보 수집\n- [ ] * *취약점 관리**: 새로운 취약점 발견 시 대응 프로세스\n- [ ] * *정기 검토**: 분기별 보안 정책 및 구현 검토\n\n### ✅ 교육 및 훈련\n- [ ] * *개발자 교육**: 보안 코딩 교육 정기 실시\n- [ ] * *보안 인식**: 전 직원 대상 보안 인식 교육\n- [ ] * *모의 훈련**: 보안 사고 대응 모의 훈련\n- [ ] * *지식 공유**: 보안 관련 지식 공유 체계\n\n---\n\n##",
                "📚 참고 자료\n\n### 보안 표준 및 가이드\n- OWASP Mobile Top 10 2021\n- Android Security Documentation\n- Google Play Security Guidelines\n- NIST Mobile Security Guidelines\n\n### 도구 및 프레임워크\n- Android Security Test Framework\n- MobSF (Mobile Security Framework)\n- QARK (Quick Android Review Kit)\n- Androguard\n\n### 법적 요구사항\n- 개인정보보호법\n- 정보통신망법\n- GDPR (해외 서비스 시)\n- Google Play 정책"
            ]
        },
        {
            "filename": "Android_Security_Guidelines.md",
            "total_characters": 24913,
            "total_chunks": 19,
            "chunks": [
                "# Android 앱 보안 가이드라인\n\n## 개요\n\n본 문서는 Android 플랫폼에서 Kotlin, Compose, Hilt, Room, Clean Architecture, MVI, Flow 기반 앱 개발 시 준수해야 할 보안 기준과 구현 방법을 제시합니다.\n\n## 목차\n\n1. [보안위협 모델 (Threat Model)](#보안위협-모델)\n2. [보안 구현 가이드](#보안-구현-가이드)\n3. [플랫폼별 보안 요구사항](#플랫폼별-보안-요구사항)\n4. [코드 예제](#코드-예제)\n\n---\n\n## 보안위협 모델 (Threat Model)\n\n### 1. APK 디컴파일 위협\n- **위협 설명**: APK 파일 분석을 통한 소스 코드 및 리소스 노출\n- **영향도**: 높음\n- **대상 자산**: API 키, 암호화 키, 비즈니스 로직, strings.xml\n- **공격 시나리오**: \n  - APKTool, JADX를 통한 디컴파일\n  - DEX2JAR를 통한 Java 소스 추출\n  - 리소스 파일 분석\n\n### 2. 루팅 기기 (Root) 위협\n- **위협 설명**: 루팅된 기기에서의 앱 실행으로 인한 보안 우회\n- **영향도**: 매우 높음\n- **대상 자산**: 앱 데이터, SharedPreferences, 내부 저장소\n- **공격 시나리오**:\n  - 루트 권한을 통한 앱 데이터 접근\n  - Xposed 프레임워크를 통한 런타임 조작\n  - 메모리 덤프 및 분석\n\n### 3. Intent 스니핑 및 스푸핑\n- **위협 설명**: Intent를 통한 데이터 탈취 및 악성 Component 실행\n- **영향도**: 중간-높음\n- **대상 자산**: Intent 데이터, Activity/Service 호출\n- **공격 시나리오**:\n  - 악성 앱에서 Intent 가로채기\n  - 가짜 Activity를 통한 피싱\n  - Broadcast 메시지 스니핑\n\n### 4. Room 데이터베이스 보안 위협\n- **위협 설명**: SQLite 파일 직접 접근 및 SQL 인젝션\n- **영향도**: 높음\n- **대상 자산**: 사용자 데이터, 인증 정보\n- **공격 시나리오**:\n  - 루팅된 기기에서 DB 파일 복사\n  - SQL 인젝션을 통한 데이터 조작\n  - 백업을 통한 데이터 유출\n\n### 5. 네트워크 트래픽 분석\n- **위협 설명**: HTTP/HTTPS 통신 분석 및 중간자 공격\n- **영향도**: 높음\n- **대상 자산**: API 통신 데이터, 인증 토큰\n- **공격 시나리오**:\n  - 프록시를 통한 트래픽 분석\n  - 인증서 우회 공격\n  - DNS 하이재킹\n\n### 6. 코드 인젝션 및 후킹\n- **위징 설명**: 런타임 코드 조작 및 메소드 후킹\n- **영향도**: 높음\n- **대상 자산**: 앱 실행 흐름, 메소드 반환값\n- **공격 시나리오**:\n  - Frida를 통한 런타임 후킹\n  - Xposed 모듈을 통한 메소드 변경\n  - Native 코드 패칭\n\n---\n\n## 보안 구현 가이드\n\n### 1. 데이터 저장 보안\n\n####",
                "Room 데이터베이스 암호화 (SQLCipher)\n```kotlin\n// build.gradle (Module: app)\ndependencies {\n    implementation \"net.zetetic:android-database-sqlcipher:4.5.4\"\n    implementation \"androidx.sqlite:sqlite:2.3.1\"\n}\n\n// SecureRoomDatabase.kt\nimport net.zetetic.database.sqlcipher.SupportOpenHelperFactory\n\n@Database(\n    entities = [UserEntity::class, SecureDataEntity::class],\n    version = 1,\n    exportSchema = false\n)\n@TypeConverters(Converters::class)\nabstract class SecureRoomDatabase : RoomDatabase() {\n    \n    abstract fun userDao(): UserDao\n    abstract fun secureDataDao(): SecureDataDao\n    \n    companion object {\n        @Volatile\n        private var INSTANCE: SecureRoomDatabase? = null\n        \n        fun getDatabase(\n            context: Context,\n            passphrase: String\n        ): SecureRoomDatabase {\n            return INSTANCE ?: synchronized(this) {\n                val supportFactory",
                "= SupportOpenHelperFactory(\n                    passphrase.toByteArray()\n                )\n                \n                val instance = Room.databaseBuilder(\n                    context.applicationContext,\n                    SecureRoomDatabase::class.java,\n                    \"secure_database\"\n                )\n                .openHelperFactory(supportFactory)\n                .build()\n                \n                INSTANCE = instance\n                instance\n            }\n        }\n        \n        // 암호화 키 생성\n        fun generateDatabasePassphrase(): String {\n            val random = SecureRandom()\n            val bytes = ByteArray(32)\n            random.nextBytes(bytes)\n            return Base64.encodeToString(bytes, Base64.NO_WRAP)\n        }\n    }\n}\n```\n\n#### 암호화된 SharedPreferences 구현\n```kotlin\nimport androidx.security.crypto.EncryptedSharedPreferences\nimport androidx.security.crypto.MasterKey\n\nclass SecurePreferencesManager @Inject constructor(\n    @ApplicationContext private val context: Context\n) {\n    \n    private val masterKey = MasterKey.Builder(context)\n        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n        .build()\n    \n    private val encryptedPrefs = EncryptedSharedPreferences.create(\n        context,\n        PREFS_FILE_NAME,\n        masterKey,\n        EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n        EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n    )\n    \n    // 토큰 저장\n    fun saveToken(token: String) {\n        encryptedPrefs.edit()\n            .putString(KEY_AUTH_TOKEN, token)\n            .apply()\n    }\n    \n    // 토큰 조회\n    fun getToken(): String?",
                "{\n        return encryptedPrefs.getString(KEY_AUTH_TOKEN, null)\n    }\n    \n    // 민감 정보 저장\n    fun saveSecureData(key: String, value: String) {\n        encryptedPrefs.edit()\n            .putString(key, value)\n            .apply()\n    }\n    \n    companion object {\n        private const val PREFS_FILE_NAME = \"secure_prefs\"\n        private const val KEY_AUTH_TOKEN = \"auth_token\"\n    }\n}\n```\n\n### 2. 네트워크 보안\n\n#### Certificate Pinning with OkHttp\n```kotlin\nimport okhttp3.CertificatePinner\nimport okhttp3.OkHttpClient\nimport okhttp3.logging.HttpLoggingInterceptor\nimport java.security.cert.CertificateException\nimport javax.net.ssl.SSLContext\nimport javax.net.ssl.TrustManager\nimport javax.net.ssl.X509TrustManager\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject NetworkModule {\n    \n    @Provides\n    @Singleton\n    fun provideSecureOkHttpClient(): OkHttpClient {\n        val certificatePinner = CertificatePinner.Builder()\n            .add(\"yourdomain.com\", \"sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\")\n            .add(\"yourdomain.com\", \"sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=\")\n            .build()\n        \n        val loggingInterceptor",
                "= HttpLoggingInterceptor().apply {\n            level = if (BuildConfig.DEBUG) {\n                HttpLoggingInterceptor.Level.BODY\n            } else {\n                HttpLoggingInterceptor.Level.NONE\n            }\n        }\n        \n        return OkHttpClient.Builder()\n            .certificatePinner(certificatePinner)\n            .addInterceptor(AuthInterceptor())\n            .addInterceptor(loggingInterceptor)\n            .build()\n    }\n}\n\nclass AuthInterceptor @Inject constructor(\n    private val securePrefs: SecurePreferencesManager\n) : Interceptor {\n    \n    override fun intercept(chain: Interceptor.Chain): Response {\n        val original = chain.request()\n        val token = securePrefs.getToken()\n        \n        val request = if (token != null) {\n            original.newBuilder()\n                .header(\"Authorization\", \"Bearer $token\")\n                .header(\"User-Agent\", \"YourApp/${BuildConfig.VERSION_NAME}\")\n                .build()\n        } else {\n            original\n        }\n        \n        return chain.proceed(request)\n    }\n}\n```\n\n####",
                "Network Security Config\n```xml\n<!-- res/xml/network_security_config.xml -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<network-security-config>\n    <domain-config cleartextTrafficPermitted=\"false\">\n        <domain includeSubdomains=\"true\">yourdomain.com</domain>\n        <pin-set expiration=\"2025-12-31\">\n            <pin digest=\"SHA-256\">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=</pin>\n            <pin digest=\"SHA-256\">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB=</pin>\n        </pin-set>\n    </domain-config>\n    \n    <!-- 개발 환경에서만 cleartext 허용 -->\n    <domain-config cleartextTrafficPermitted=\"true\">\n        <domain includeSubdomains=\"true\">localhost</domain>\n        <domain includeSubdomains=\"true\">10.0.2.2</domain>\n    </domain-config>\n</network-security-config>\n```\n\n### 3. 인증 및 권한 관리\n\n#### Biometric 인증 구현\n```kotlin\nimport androidx.biometric.BiometricManager\nimport androidx.biometric.BiometricPrompt\nimport androidx.core.content.ContextCompat\n\n@AndroidEntryPoint\nclass BiometricAuthManager @Inject constructor() {\n    \n    fun isBiometricAvailable(context: Context): Boolean {\n        return BiometricManager.from(context)\n            .canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_WEAK) == \n            BiometricManager.BIOMETRIC_SUCCESS\n    }\n    \n    fun showBiometricPrompt(\n        fragmentActivity: FragmentActivity,\n        onSuccess: () -> Unit,\n        onError: (String) -> Unit\n    ) {\n        val executor = ContextCompat.getMainExecutor(fragmentActivity)\n        val biometricPrompt = BiometricPrompt(\n            fragmentActivity,\n            executor,\n            object : BiometricPrompt.AuthenticationCallback() {\n                override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) {\n                    super.onAuthenticationSucceeded(result)\n                    onSuccess()\n                }\n                \n                override fun onAuthenticationError(errorCode: Int, errString: CharSequence) {\n                    su",
                "per.onAuthenticationError(errorCode, errString)\n                    onError(errString.toString())\n                }\n            }\n        )\n        \n        val promptInfo = BiometricPrompt.PromptInfo.Builder()\n            .setTitle(\"생체 인증\")\n            .setSubtitle(\"앱에 접근하려면 생체 인증이 필요합니다\")\n            .setNegativeButtonText(\"취소\")\n            .build()\n        \n        biometricPrompt.authenticate(promptInfo)\n    }\n}\n```\n\n#### JWT 토큰 관리\n```kotlin\nimport io.jsonwebtoken.Claims\nimport io.jsonwebtoken.Jwts\nimport java.util.Date\n\nclass JwtManager @Inject constructor(\n    private val securePrefs: SecurePreferencesManager\n) {\n    \n    fun saveTokens(accessToken: String, refreshToken: String) {\n        securePrefs.saveSecureData(KEY_ACCESS_TOKEN, accessToken)\n        securePrefs.saveSecureData(KEY_REFRESH_TOKEN, refreshToken)\n    }\n    \n    fun getAccessToken(): String?",
                "{\n        return securePrefs.getSecureData(KEY_ACCESS_TOKEN)\n    }\n    \n    fun isTokenExpired(token: String): Boolean {\n        return try {\n            val claims = parseToken(token)\n            val expiration = claims.expiration\n            expiration.before(Date())\n        } catch (e: Exception) {\n            true\n        }\n    }\n    \n    private fun parseToken(token: String): Claims {\n        return Jwts.parser()\n            .parseClaimsJws(token)\n            .body\n    }\n    \n    fun clearTokens() {\n        securePrefs.removeKey(KEY_ACCESS_TOKEN)\n        securePrefs.removeKey(KEY_REFRESH_TOKEN)\n    }\n    \n    companion object {\n        private const val KEY_ACCESS_TOKEN = \"access_token\"\n        private const val KEY_REFRESH_TOKEN = \"refresh_token\"\n    }\n}\n```\n\n### 4. Clean Architecture + MVI 보안 패턴\n\n#### 보안 Repository 구현\n```kotlin\ninterface SecurityRepository {\n    suspend fun authenticateUser(credentials: UserCredentials): Result<AuthToken>\n    suspend fun refreshToken(): Result<AuthToken>\n    suspend fun logout(): Result<Unit>\n    fun isAuthenticated(): Boolean\n}\n\nclass SecurityRepositoryImpl @Inject constructor(\n    private val apiService: ApiService,\n    private val jwtManager: JwtManager,\n    private val biometricManager: BiometricAuthManager\n) : SecurityRepository {\n    \n    override suspend fun authenticateUser(\n        credentials: UserCredentials\n    ): Result<AuthToken> = runCatching {\n        // 입력값 검증\n        val validatedCredentials = validateCredentials(credentials)\n        \n        // API 호출\n        val response = apiService.login(validatedCredentials)\n        \n        // 토큰 저장\n        jwtManager.saveTokens(response.accessToken, response.refreshToken)\n        \n        AuthToken(response.accessToken)\n    }\n    \n    override suspend fun refreshToken():",
                "Result<AuthToken> = runCatching {\n        val refreshToken = jwtManager.getRefreshToken() \n            ?: throw SecurityException(\"Refresh token not found\")\n        \n        val response = apiService.refreshToken(refreshToken)\n        jwtManager.saveTokens(response.accessToken, response.refreshToken)\n        \n        AuthToken(response.accessToken)\n    }\n    \n    private fun validateCredentials(credentials: UserCredentials): UserCredentials {\n        require(credentials.email.isNotBlank()) { \"이메일이 비어있습니다\" }\n        require(credentials.password.isNotBlank()) { \"비밀번호가 비어있습니다\" }\n        require(android.util.Patterns.EMAIL_ADDRESS.matcher(credentials.email).matches()) {\n            \"유효하지 않은 이메일 형식입니다\"\n        }\n        return credentials\n    }\n}\n```\n\n#### 보안 UseCase\n```kotlin\nclass AuthenticateUserUseCase @Inject constructor(\n    private val securityRepository: SecurityRepository,\n    private val inputValidator: InputValidator\n) {\n    \n    suspend operator fun invoke(\n        email: String,\n        password: String\n    ): Result<AuthToken> = runCatching {\n        // 입력값 sanitization\n        val sanitizedEmail = inputValidator.sanitizeEmail(email)\n        val sanitizedPassword = inputValidator.sanitizePassword(password)\n        \n        // 비밀번호 강도 검증\n        inputValidator.validatePasswordStrength(sanitizedPassword)\n        \n        val credentials = UserCredentials(sanitizedEmail, sanitizedPassword)\n        securityRepository.authenticateUser(credentials).getOrThrow()\n    }\n}\n\nclass InputValidator @Inject constructor() {\n    \n    fun sanitizeEmail(email: String): String {\n        return email.trim()\n            .lowercase()\n            .replace(Regex(\"[<>\\\"'/]\"), \"\")\n    }\n    \n    fun sanitizePassword(password: String):",
                "String {\n        return password.replace(Regex(\"[<>\\\"']\"), \"\")\n    }\n    \n    fun validatePasswordStrength(password: String) {\n        require(password.length >= 8) { \"비밀번호는 최소 8자 이상이어야 합니다\" }\n        require(password.any { it.isUpperCase() }) { \"대문자가 포함되어야 합니다\" }\n        require(password.any { it.isLowerCase() }) { \"소문자가 포함되어야 합니다\" }\n        require(password.any { it.isDigit() }) { \"숫자가 포함되어야 합니다\" }\n        require(password.any { \"!@#$%^&*\".contains(it) }) { \"특수문자가 포함되어야 합니다\" }\n    }\n}\n```\n\n#### 보안 ViewModel (MVI 패턴)\n```kotlin\n@HiltViewModel\nclass SecurityViewModel @Inject constructor(\n    private val authenticateUseCase: AuthenticateUserUseCase,\n    private val rootDetector: RootDetector\n) : ViewModel() {\n    \n    private val _uiState = MutableStateFlow(SecurityUiState())\n    val uiState: StateFlow<SecurityUiState> = _uiState.asStateFlow()\n    \n    init {\n        checkDeviceSecurity()\n    }\n    \n    fun onIntent(intent: SecurityIntent) {\n        when (intent) {\n            is SecurityIntent.Login -> handleLogin(intent.email, intent.password)\n            is SecurityIntent.Logout -> handleLogout()\n            SecurityIntent.CheckBiometric -> checkBiometricAvailability()\n        }\n    }\n    \n    private fun handleLogin(email: String, password: String) {\n        viewModelScope.launch {\n            _uiState.update { it.copy(isLoading = true) }\n            \n            try {\n                val result = authenticateUseCase(email, password)\n                \n                if (result.isSuccess) {\n                    _uiState.update { \n                        it.copy(\n                            isLoading = false,\n                            isAuthenticated = true,\n                            error = null\n                        )\n                    }\n                } else {\n                    _uiState.update { \n                        it.copy(\n                            isLoading = false,\n                            error = result.exceptionOrNull()?.message",
                ")\n                    }\n                }\n            } catch (e: Exception) {\n                _uiState.update { \n                    it.copy(\n                        isLoading = false,\n                        error = \"인증에 실패했습니다: ${e.message}\"\n                    )\n                }\n            }\n        }\n    }\n    \n    private fun checkDeviceSecurity() {\n        viewModelScope.launch {\n            if (rootDetector.isRooted()) {\n                _uiState.update {\n                    it.copy(\n                        securityWarning = \"루팅된 기기에서는 보안이 보장되지 않습니다.\"\n                    )\n                }\n            }\n        }\n    }\n}\n\ndata class SecurityUiState(\n    val isLoading: Boolean = false,\n    val isAuthenticated: Boolean = false,\n    val error: String?",
                "= null,\n    val securityWarning: String?",
                "= null\n)\n\nsealed class SecurityIntent {\n    data class Login(val email: String, val password: String) : SecurityIntent()\n    object Logout : SecurityIntent()\n    object CheckBiometric : SecurityIntent()\n}\n```\n\n### 5. 루트 탐지\n\n#### 종합적인 루트 탐지\n```kotlin\n@Singleton\nclass RootDetector @Inject constructor(\n    @ApplicationContext private val context: Context\n) {\n    \n    private val rootApps = listOf(\n        \"com.noshufou.android.su\",\n        \"com.noshufou.android.su.elite\",\n        \"eu.chainfire.supersu\",\n        \"com.koushikdutta.superuser\",\n        \"com.thirdparty.superuser\",\n        \"com.yellowes.su\",\n        \"com.koushikdutta.rommanager\",\n        \"com.koushikdutta.rommanager.license\",\n        \"com.dimonvideo.luckypatcher\",\n        \"com.chelpus.lackypatch\",\n        \"com.ramdroid.appquarantine\",\n        \"com.ramdroid.appquarantinepro\"\n    )\n    \n    private val rootFiles = listOf(\n        \"/sbin/su\",\n        \"/system/bin/su\",\n        \"/system/xbin/su\",\n        \"/data/local/xbin/su\",\n        \"/data/local/bin/su\",\n        \"/system/sd/xbin/su\",\n        \"/system/bin/failsafe/su\",\n        \"/data/local/su\",\n        \"/su/bin/su\"\n    )\n    \n    fun isRooted(): Boolean {\n        return checkRootApps() || \n               checkRootFiles() || \n               checkSUCommand() ||\n               checkRootProperties() ||\n               checkTestKeys()\n    }\n    \n    private fun checkRootApps(): Boolean {\n        val packageManager = context.packageManager\n        return rootApps.any { packageName ->\n            try {\n                packageManager.getPackageInfo(packageName, 0)\n                true\n            } catch (e: PackageManager.NameNotFoundException) {\n                false\n            }\n        }\n    }\n    \n    private fun checkRootFiles(): Boolean {\n        return rootFiles.any { path ->\n            val file = File(path)\n            file.exists() && file.canExecute()\n        }\n    }\n    \n    private fun checkSUCommand(): Boolean {\n        return try {\n            Runtime.ge",
                "tRuntime().exec(\"su\").waitFor() == 0\n        } catch (e: Exception) {\n            false\n        }\n    }\n    \n    private fun checkRootProperties(): Boolean {\n        val buildTags = Build.TAGS\n        return buildTags != null && buildTags.contains(\"test-keys\")\n    }\n    \n    private fun checkTestKeys(): Boolean {\n        val keys = Build.TAGS\n        return keys != null && keys.contains(\"test-keys\")\n    }\n}\n```\n\n### 6. 코드 난독화 및 보호\n\n#### ProGuard 설정\n```proguard\n# proguard-rules.pro\n\n# 기본 최적화 설정\n-optimizationpasses 5\n-dontusemixedcaseclassnames\n-dontskipnonpubliclibraryclasses\n-dontpreverify\n-verbose\n\n# 코드 난독화\n-obfuscationdictionary obfuscation-dictionary.txt\n-classobfuscationdictionary obfuscation-dictionary.txt\n-packageobfuscationdictionary obfuscation-dictionary.txt\n\n# 문자열 암호화 (상용 도구 사용 시)\n-adaptclassstrings\n-adaptresourcefilenames\n-adaptresourcefilecontents\n\n# 중요 클래스/메소드 난독화 강화\n-keepnames class !com.yourapp.security.**,!com.yourapp.crypto.*",
                "* { *; }\n\n# 디버깅 정보 제거\n-renamesourcefileattribute SourceFile\n-keepattributes SourceFile,LineNumberTable\n\n# 네이티브 메소드 보호\n-keepclasseswithmembernames class * {\n    native <methods>;\n}\n\n# Reflection 사용 클래스 보호\n-keep class com.yourapp.model.* * { *; }\n\n# 예외 처리\n-keepattributes *Annotation*\n-keepattributes Signature\n-keepattributes InnerClasses\n-keepattributes EnclosingMethod\n```\n\n#### 안티 디버깅\n```kotlin\nobject AntiDebug {\n    \n    init {\n        System.loadLibrary(\"antidebug\")\n    }\n    \n    // JNI를 통한 네이티브 안티 디버깅\n    external fun checkDebugger(): Boolean\n    external fun preventDebugging(): Int\n    \n    fun isDebugging(): Boolean {\n        return Debug.isDebuggerConnected() || \n               isDebuggerAttached() ||\n               checkDebugger()\n    }\n    \n    private fun isDebuggerAttached(): Boolean {\n        return try {\n            Debug.waitingForDebugger()\n        } catch (e: Exception) {\n            false\n        }\n    }\n    \n    fun performAntiDebugCheck() {\n        if (isDebugging()) {\n            // 디버거 탐지 시 앱 종료 또는 보안 조치\n            exitProcess(-1)\n        }\n    }\n}\n```\n\n### 7. 앱 무결성 검증\n\n#### APK Signature 검증\n```kotlin\nclass AppIntegrityChecker @Inject constructor(\n    @ApplicationContext private val context: Context\n) {\n    \n    private val expectedSignature",
                "= \"YOUR_EXPECTED_SIGNATURE_HASH\"\n    \n    fun verifyAppSignature(): Boolean {\n        return try {\n            val packageInfo = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n                context.packageManager.getPackageInfo(\n                    context.packageName,\n                    PackageManager.GET_SIGNING_CERTIFICATES\n                )\n            } else {\n                @Suppress(\"DEPRECATION\")\n                context.packageManager.getPackageInfo(\n                    context.packageName,\n                    PackageManager.GET_SIGNATURES\n                )\n            }\n            \n            val signatures = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {\n                packageInfo.signingInfo.apkContentsSigners\n            } else {\n                @Suppress(\"DEPRECATION\")\n                packageInfo.signatures\n            }\n            \n            signatures.any { signature ->\n                val signatureHash = sha256(signature.toByteArray())\n                signatureHash == expectedSignature\n            }\n        } catch (e: Exception) {\n            false\n        }\n    }\n    \n    private fun sha256(data: ByteArray): String {\n        val digest = MessageDigest.getInstance(\"SHA-256\")\n        val hash = digest.digest(data)\n        return Base64.encodeToString(hash, Base64.NO_WRAP)\n    }\n    \n    fun checkAppIntegrity() {\n        if (!verifyAppSignature()) {\n            // 서명 검증 실패 시 보안 조치\n            throw SecurityException(\"앱 무결성 검증에 실패했습니다.\")\n        }\n    }\n}\n```\n\n---\n\n## 플랫폼별 보안 요구사항\n\n###",
                "1. Android Manifest 보안 설정\n\n```xml\n<!-- AndroidManifest.xml -->\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.yourapp\">\n    \n    <!-- 네트워크 보안 설정 -->\n    <application\n        android:networkSecurityConfig=\"@xml/network_security_config\"\n        android:allowBackup=\"false\"\n        android:allowClearUserData=\"false\"\n        android:debuggable=\"false\"\n        android:extractNativeLibs=\"false\"\n        android:hardwareAccelerated=\"true\"\n        android:largeHeap=\"false\"\n        android:supportsRtl=\"true\"\n        android:usesCleartextTraffic=\"false\">\n        \n        <!-- 백업 방지 -->\n        <meta-data\n            android:name=\"android.app.backup.full_backup_content\"\n            android:resource=\"@xml/backup_rules\" />\n        \n        <!-- 스크린 캡처 방지 (민감한 화면) -->\n        <activity\n            android:name=\".ui.MainActivity\"\n            android:windowSoftInputMode=\"adjustResize\"\n            android:screenOrientation=\"portrait\" />\n            \n    </application>\n    \n    <!-- 필요한 권한만 요청 -->\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.USE_BIOMETRIC\" />\n    \n    <!-- 위험한 권한 제한 -->\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n        android:maxSdkVersion=\"28\" />\n        \n</manifest>\n```\n\n### 2. 백업 보안 설정\n```xml\n<!-- res/xml/backup_rules.xml -->\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<full-backup-content>\n    <exclude domain=\"sharedpref\" path=\"secure_prefs.xml\"/>\n    <exclude domain=\"database\" path=\"secure_database.db\"/>\n    <exclude domain=\"file\" path=\"sensitive_data/\"/>\n</full-backup-content>\n```\n\n### 3. Build Configuration 보안\n```kotlin\n// build.gradle (Module: app)\nandroid {\n    compileSdk 34\n    \n    defaultConfig {\n        minSdk 24\n        targetSdk 34\n        \n        // 디버그 빌드 타입에서만 디버깅 허용\n        buildConfigField(\"boolean\", \"DEBUG_MODE\", \"false\")\n    }\n    \n    buildTypes {\n        release {\n            isMinifyEnabled = true",
                "isShrinkResources = true\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n            \n            // 릴리스 빌드에서 로그 제거\n            buildConfigField(\"boolean\", \"ENABLE_LOGGING\", \"false\")\n        }\n        \n        debug {\n            isMinifyEnabled = false\n            buildConfigField(\"boolean\", \"ENABLE_LOGGING\", \"true\")\n        }\n    }\n    \n    // 네이티브 코드 보호\n    packagingOptions {\n        pickFirst(\"**/libc++_shared.so\")\n        pickFirst(\"**/libjsc.so\")\n    }\n}\n```\n\n---\n\n## 보안 구현 체크리스트\n\n### ✅ 데이터 저장 보안\n- [ ]",
                "Room 데이터베이스 SQLCipher 암호화\n- [ ] EncryptedSharedPreferences 사용\n- [ ] 민감정보 메모리 클리어\n- [ ] 임시 파일 암호화\n- [ ] 외부 저장소 사용 금지\n\n### ✅ 네트워크 보안\n- [ ] HTTPS 통신만 허용\n- [ ] Certificate Pinning 구현\n- [ ] Network Security Config 설정\n- [ ] API 키 하드코딩 금지\n- [ ] 요청/응답 데이터 검증\n\n### ✅ 인증 및 권한\n- [ ] 생체 인증 구현\n- [ ] JWT 토큰 만료 검증\n- [ ] 권한 최소화 원칙\n- [ ] 세션 타임아웃 구현\n- [ ] 다중 인증 지원\n\n### ✅ 코드 보호\n- [ ] ProGuard/R8 난독화\n- [ ] 안티 디버깅\n- [ ] 루트 탐지\n- [ ] APK 서명 검증\n- [ ] 코드 무결성 검사\n\n### ✅ 런타임 보안\n- [ ] Intent 필터 검증\n- [ ] Broadcast 보안\n- [ ] Content Provider 보안\n- [ ] 백그라운드 제한\n- [ ] 메모리 덤프 방지\n\n### ✅ 빌드 및 배포\n- [ ] 디버그 정보 제거\n- [ ] 로깅 제거 (릴리스)\n- [ ] 백업 제한\n- [ ] APK 최적화\n- [ ] 서명 키 보안 관리\n\n---\n\n## 참고 자료\n\n- [Android Security Documentation](https://developer.android.com/topic/security)\n- [OWASP Mobile Security Testing Guide](https://owasp.org/www-project-mobile-security-testing-guide/)\n- [Android App Bundle Security](https://developer.android.com/guide/app-bundle/app-signing)\n- [Kotlin Security Best Practices](https://kotlinlang.org/docs/security.html)"
            ]
        },
        {
            "filename": "Android_Security_Testing_Environment.md",
            "total_characters": 51157,
            "total_chunks": 38,
            "chunks": [
                "# Android 보안 테스트 환경 구성 가이드\n\n## 개요\n\n본 문서는 Android 앱의 보안 테스트를 위한 종합적인 환경 구성 가이드입니다. OpenSW 도구들을 활용하여 정적 분석, 동적 분석, 침투 테스트를 수행할 수 있는 환경을 구축하는 방법을 설명합니다.\n\n## 목차\n\n1. [테스트 환경 개요](#테스트-환경-개요)\n2. [정적 분석 환경 구성](#정적-분석-환경-구성)\n3. [동적 분석 환경 구성](#동적-분석-환경-구성)\n4. [네트워크 분석 환경](#네트워크-분석-환경)\n5. [자동화 테스트 환경](#자동화-테스트-환경)\n6. [CI/CD 통합](#cicd-통합)\n\n---\n\n## 테스트 환경 개요\n\n### 필요 하드웨어/소프트웨어\n- **개발 환경**: Android Studio, SDK Tools\n- **테스트 기기**: 루팅된 Android 기기 또는 에뮬레이터\n- **분석 서버**: Docker 지원 Linux/macOS/Windows\n- **네트워크 분석**: 프록시 서버 환경\n\n### 테스트 유형별 도구 매트릭스\n\n| 테스트 유형 | 도구 | 용도 | 라이선스 |\n|------------|------|------|----------|\n| 정적 분석 | MobSF | 종합 분석 | LGPL-3.0 |\n| 정적 분석 | QARK | Android 전용 | Apache-2.0 |\n| 정적 분석 | SonarQube | 코드 품질 | LGPL-3.0 |\n| 정적 분석 | SpotBugs | 버그 패턴 | LGPL-2.1 |\n| 동적 분석 | Frida | 런타임 분석 | wxWindows |\n| 동적 분석 | Xposed | 시스템 후킹 | Apache-2.0 |\n| 네트워크 | OWASP ZAP | 웹 취약점 | Apache-2.0 |\n| 네트워크 | Burp Suite | HTTP 프록시 | PortSwigger |\n| 침투테스트 | Drozer | Android 전용 | BSD-3 |\n| APK 분석 | APKTool | APK 디컴파일 | Apache-2.0 |\n| APK 분석 | JADX | DEX → Java | Apache-2.0 |\n\n---\n\n## 정적 분석 환경 구성\n\n###",
                "1. MobSF (Mobile Security Framework) 설치\n\n#### Docker 기반 설치\n```bash\n# MobSF Docker 컨테이너 실행\ndocker pull opensecurity/mobsf\ndocker run -it --rm \\\n    -p 8000:8000 \\\n    -v ~/mobsf_uploads:/home/mobsf/Mobile-Security-Framework-MobSF/uploads \\\n    opensecurity/mobsf:latest\n\n# 백그라운드 실행\ndocker run -d --name mobsf \\\n    -p 8000:8000 \\\n    -v ~/mobsf_uploads:/home/mobsf/Mobile-Security-Framework-MobSF/uploads \\\n    opensecurity/mobsf:latest\n```\n\n#### 소스 설치 (Ubuntu/Linux)\n```bash\n# 시스템 패키지 설치\nsudo apt-get update\nsudo apt-get install -y \\\n    python3 python3-pip python3-dev \\\n    git libffi-dev libssl-dev \\\n    libxml2-dev libxslt1-dev \\\n    libjpeg8-dev zlib1g-dev \\\n    wkhtmltopdf\n\n# MobSF 클론 및 설치\ngit clone https://github.com/MobSF/Mobile-Security-Framework-MobSF.git\ncd Mobile-Security-Framework-MobSF\n\n# Python 가상환경 생성\npython3 -m venv venv\nsource venv/bin/activate\n\n# 의존성 설치\npip3 install -r requirements.txt\n\n# 설정 파일 생성\ncp mobsf/settings.py.example mobsf/settings.py\n\n# 실행\npython3 manage.py runserver 0.0.0.0:8000\n```\n\n#### MobSF API 자동화 스크립트\n```python\n#!/usr/bin/env python3\n# mobsf_automation.py\n\nimport requests\nimport json\nimport time\nimport os\n\nclass MobSFAnalyzer:\n    def __init__(self, server='http://localhost:8000', api_key=''):\n        self.server = server\n        self.api_key = api_key\n        self.session = requests.Session()\n        if api_key:\n            self.session.headers.update({'Authorization': api_key})\n    \n    def upload_apk(self, apk_path):\n        \"\"\"APK 업로드\"\"\"\n        url = f\"{self.server}/api/v1/upload\"\n        \n        with open(apk_path, 'rb') as f:\n            files = {'file': f}\n            response = self.session.post(url, files=files)\n        \n        if response.status_code == 200:\n            result = response.json()\n            return result['hash']\n        else:\n            raise Exception(f\"업로드 실패: {response.text}\")\n    \n    def start_scan(self, file_hash, scan_type='apk'):\n        \"\"\"스캔 시작\"\"\"\n        url = f\"{self.server}/api/v1/scan\"",
                "data = {\n            'hash': file_hash,\n            'scan_type': scan_type,\n            'file_name': 'app.apk'\n        }\n        \n        response = self.session.post(url, data=data)\n        if response.status_code == 200:\n            return response.json()\n        else:\n            raise Exception(f\"스캔 실패: {response.text}\")\n    \n    def get_report(self, file_hash, report_type='json'):\n        \"\"\"리포트 조회\"\"\"\n        if report_type == 'json':\n            url = f\"{self.server}/api/v1/report_json\"\n        elif report_type == 'pdf':\n            url = f\"{self.server}/api/v1/download_pdf\"\n        \n        data = {'hash': file_hash}\n        response = self.session.post(url, data=data)\n        \n        if response.status_code == 200:\n            if report_type == 'json':\n                return response.json()\n            else:\n                return response.content\n        else:\n            raise Exception(f\"리포트 조회 실패: {response.text}\")\n    \n    def analyze_apk(self, apk_path, wait_time=60):\n        \"\"\"APK 전체 분석 프로세스\"\"\"\n        print(f\"APK 분석 시작: {apk_path}\")\n        \n        # 1. 업로드\n        file_hash = self.upload_apk(apk_path)\n        print(f\"업로드 완료.",
                "Hash: {file_hash}\")\n        \n        # 2. 스캔 시작\n        scan_result = self.start_scan(file_hash)\n        print(\"스캔 시작됨\")\n        \n        # 3. 대기\n        print(f\"{wait_time}초 대기 중...\")\n        time.sleep(wait_time)\n        \n        # 4. 리포트 생성\n        json_report = self.get_report(file_hash, 'json')\n        pdf_report = self.get_report(file_hash, 'pdf')\n        \n        # 5. 리포트 저장\n        os.makedirs('reports', exist_ok=True)\n        \n        with open(f'reports/{file_hash}_report.json', 'w', encoding='utf-8') as f:\n            json.dump(json_report, f, indent=2, ensure_ascii=False)\n        \n        with open(f'reports/{file_hash}_report.pdf', 'wb') as f:\n            f.write(pdf_report)\n        \n        print(f\"분석 완료. 리포트 저장됨: reports/{file_hash}_*\")\n        return json_report\n\n# 사용 예\nif __name__ == \"__main__\":\n    analyzer = MobSFAnalyzer()\n    result = analyzer.analyze_apk('path/to/your/app.apk')\n    print(f\"보안 점수: {result.get('security_score', 'N/A')}\")\n```\n\n### 2. QARK (Quick Android Review Kit) 설정\n\n#### 설치\n```bash\n# Python pip으로 설치\npip3 install qark\n\n# 또는 소스에서 설치\ngit clone https://github.com/linkedin/qark.git\ncd qark\npip3 install -r requirements.txt\npip3 install .\n```\n\n#### QARK 분석 스크립트\n```bash\n#!/bin/bash\n# run_qark.sh\n\nAPK_PATH=\"$1\"\nOUTPUT_DIR=\"qark_reports\"\n\nmkdir -p $OUTPUT_DIR\n\necho \"QARK 분석 시작: $APK_PATH\"\n\n# APK 분석\nqark --apk $APK_PATH \\\n     --report-type json \\\n     --report-dir $OUTPUT_DIR\n\n# 소스 코드 분석 (필요시)\nif [ -d \"src/\" ]; then\n    qark --java src/ \\\n         --report-type both \\\n         --report-dir $OUTPUT_DIR/source\nfi\n\necho \"QARK 분석 완료.",
                "결과: $OUTPUT_DIR/\"\n\n# 주요 취약점 요약\npython3 -c \"\nimport json\nimport os\n\njson_files = [f for f in os.listdir('$OUTPUT_DIR') if f.endswith('.json')]\nfor json_file in json_files:\n    with open('$OUTPUT_DIR/' + json_file) as f:\n        data = json.load(f)\n        issues = data.get('results', [])\n        high = len([i for i in issues if i.get('severity') == 'HIGH'])\n        medium = len([i for i in issues if i.get('severity') == 'MEDIUM'])\n        print(f'QARK 결과 ({json_file}): 높음 {high}개, 중간 {medium}개')\n\"\n```\n\n### 3. SonarQube Android 설정\n\n####",
                "Docker Compose 설정\n```yaml\n# docker-compose.sonar.yml\nversion: '3.8'\n\nservices:\n  sonarqube:\n    image: sonarqube:9-community\n    container_name: sonarqube-android\n    environment:\n      - SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true\n      - SONAR_JDBC_URL=jdbc:postgresql://db:5432/sonar\n      - SONAR_JDBC_USERNAME=sonar\n      - SONAR_JDBC_PASSWORD=sonar_password\n    ports:\n      - \"9000:9000\"\n    volumes:\n      - sonarqube_data:/opt/sonarqube/data\n      - sonarqube_logs:/opt/sonarqube/logs\n      - sonarqube_extensions:/opt/sonarqube/extensions\n    depends_on:\n      - db\n    networks:\n      - sonarnet\n\n  db:\n    image: postgres:13\n    container_name: sonarqube-db\n    environment:\n      - POSTGRES_USER=sonar\n      - POSTGRES_PASSWORD=sonar_password\n      - POSTGRES_DB=sonar\n    volumes:\n      - postgresql_data:/var/lib/postgresql/data\n    networks:\n      - sonarnet\n\nvolumes:\n  sonarqube_data:\n  sonarqube_logs:\n  sonarqube_extensions:\n  postgresql_data:\n\nnetworks:\n  sonarnet:\n    driver: bridge\n```\n\n#### Android 프로젝트 SonarQube 설정\n```properties\n# sonar-project.properties\nsonar.projectKey=android-security-test\nsonar.projectName=Android Security Test\nsonar.projectVersion=1.0\n\nsonar.sources=app/src/main/java,app/src/main/kotlin\nsonar.tests=app/src/test/java,app/src/androidTest/java\nsonar.java.binaries=app/build/intermediates/classes\nsonar.android.lint.report=app/build/reports/lint-results.xml\n\nsonar.exclusions=**/R.java,**/*.xml,**/build/**,**/gen/**\nsonar.coverage.exclusions=**/test/**,**/androidTest/**\n\n# 보안 관련 규칙 활성화\nsonar.java.spotbugs.reportPaths=app/build/reports/spotbugs/main.xml\nsonar.kotlin.detekt.reportPaths=app/build/reports/detekt/detekt.xml\n```\n\n#### Gradle 통합\n```gradle\n// app/build.gradle\nplugins {\n    id 'org.sonarqube' version '3.4.0.2513'\n}\n\nsonarqube {\n    properties {\n        property \"sonar.projectKey\", \"android-security-test\"\n        property \"sonar.projectName\", \"Android Security Test\"\n        property \"sonar.host.url\", \"http://localhost:9000\"\n        prope",
                "rty \"sonar.login\", \"your-sonar-token\"\n        \n        property \"sonar.sources\", \"src/main/java,src/main/kotlin\"\n        property \"sonar.tests\", \"src/test/java,src/androidTest/java\"\n        property \"sonar.java.binaries\", \"build/intermediates/classes\"\n        \n        property \"sonar.android.lint.report\", \"build/reports/lint-results.xml\"\n        property \"sonar.kotlin.detekt.reportPaths\", \"build/reports/detekt/detekt.xml\"\n    }\n}\n\n// 보안 분석 도구 추가\ndependencies {\n    implementation 'com.github.spotbugs:spotbugs-gradle-plugin:4.7.1'\n    implementation 'io.gitlab.arturbosch.detekt:detekt-gradle-plugin:1.21.0'\n}\n\n// SpotBugs 설정\nspotbugs {\n    includeFilter = file(\"spotbugs-security-include.xml\")\n    excludeFilter = file(\"spotbugs-security-exclude.xml\")\n    effort = \"max\"\n    reportLevel = \"low\"\n}\n\n// Detekt 설정 (Kotlin)\ndetekt {\n    config = files(\"detekt-config.yml\")\n    buildUponDefaultConfig = true\n}\n```\n\n---\n\n## 동적 분석 환경 구성\n\n###",
                "1. Android 에뮬레이터 설정\n\n#### AVD 생성 스크립트\n```bash\n#!/bin/bash\n# create_test_avd.sh\n\nAVD_NAME=\"SecurityTestDevice\"\nAPI_LEVEL=\"30\"\nABI=\"google_apis/x86_64\"\nDEVICE=\"pixel_4\"\n\necho \"Android 보안 테스트용 AVD 생성...\"\n\n# SDK 패키지 다운로드\nsdkmanager \"system-images;android-${API_LEVEL};${ABI}\"\n\n# AVD 생성\necho \"no\" | avdmanager create avd \\\n    --force \\\n    --name $AVD_NAME \\\n    --abi $ABI \\\n    --package \"system-images;android-${API_LEVEL};${ABI}\" \\\n    --device $DEVICE\n\n# AVD 설정 파일 수정 (루팅 활성화)\nAVD_PATH=\"$HOME/.android/avd/${AVD_NAME}.avd\"\necho \"hw.keyboard=yes\" >> \"$AVD_PATH/config.ini\"\necho \"hw.gpu.enabled=yes\" >> \"$AVD_PATH/config.ini\"\necho \"hw.gpu.mode=host\" >> \"$AVD_PATH/config.ini\"\n\necho \"AVD 생성 완료: $AVD_NAME\"\necho \"실행: emulator -avd $AVD_NAME -writable-system\"\n```\n\n### 2. Frida 환경 설정\n\n#### 설치 및 설정\n```bash\n# Frida 설치\npip3 install frida-tools\n\n# Android에 Frida Server 설치\nFRIDA_VERSION=$(frida --version)\nARCH=\"arm64\" # 또는 arm, x86, x86_64\n\nwget https://github.com/frida/frida/releases/download/${FRIDA_VERSION}/frida-server-${FRIDA_VERSION}-android-${ARCH}.xz\nunxz frida-server-${FRIDA_VERSION}-android-${ARCH}.xz\n\n# 기기에 업로드 및 실행\nadb push frida-server-${FRIDA_VERSION}-android-${ARCH} /data/local/tmp/frida-server\nadb shell \"chmod 755 /data/local/tmp/frida-server\"\nadb shell \"/data/local/tmp/frida-server &\"\n```\n\n####",
                "Frida 스크립트 예제\n```javascript\n// android_security_hooks.js\nJava.perform(function() {\n    console.log(\"[+] Android 보안 후킹 스크립트 시작\");\n    \n    // 1. SQL 쿼리 모니터링\n    try {\n        var SQLiteDatabase = Java.use(\"android.database.sqlite.SQLiteDatabase\");\n        SQLiteDatabase.rawQuery.overload('java.lang.String', '[Ljava.lang.String;').implementation = function(sql, selectionArgs) {\n            console.log(\"[SQL] 쿼리 실행: \" + sql);\n            if (selectionArgs) {\n                console.log(\"[SQL] 매개변수: \" + selectionArgs);\n            }\n            return this.rawQuery(sql, selectionArgs);\n        };\n    } catch (e) {\n        console.log(\"[-] SQLiteDatabase 후킹 실패: \" + e);\n    }\n    \n    // 2. SharedPreferences 모니터링\n    try {\n        var SharedPreferencesImpl = Java.use(\"android.app.SharedPreferencesImpl\");\n        var Editor = Java.use(\"android.app.SharedPreferencesImpl$EditorImpl\");\n        \n        Editor.putString.implementation = function(key, value) {\n            console.log(\"[SharedPrefs] 저장: \" + key + \" = \" + value);\n            return this.putString(key, value);\n        };\n        \n        SharedPreferencesImpl.getString.implementation = function(key, defValue) {\n            var result = this.getString(key, defValue);\n            console.log(\"[SharedPrefs] 조회: \" + key + \" = \" + result);\n            return result;\n        };\n    } catch (e) {\n        console.log(\"[-] SharedPreferences 후킹 실패: \" + e);\n    }\n    \n    // 3. 암호화 API 모니터링\n    try {\n        var Cipher = Java.use(\"javax.crypto.Cipher\");\n        Cipher.getInstance.overload('java.lang.String').implementation = function(transformation) {\n            console.log(\"[Crypto] Cipher 생성: \" + transformation);\n            return this.getInstance(transformation);\n        };\n        \n        Cipher.doFinal.overload('[B').implementation = function(input) {\n            console.log(\"[Crypto] 암호화/복호화 실행, 입력 크기: \" + input.length);\n            return this.doFinal(input);\n        };\n    } catch (e) {\n        console.log(\"[-] Ci",
                "pher 후킹 실패: \" + e);\n    }\n    \n    // 4. 네트워크 요청 모니터링\n    try {\n        var HttpURLConnection = Java.use(\"java.net.HttpURLConnection\");\n        HttpURLConnection.setRequestMethod.implementation = function(method) {\n            console.log(\"[HTTP] 요청 메소드: \" + method);\n            return this.setRequestMethod(method);\n        };\n        \n        var URL = Java.use(\"java.net.URL\");\n        var urlConstructor = URL.$init.overload('java.lang.String');\n        urlConstructor.implementation = function(spec) {\n            console.log(\"[HTTP] URL 생성: \" + spec);\n            return urlConstructor.call(this, spec);\n        };\n    } catch (e) {\n        console.log(\"[-] HTTP 후킹 실패: \" + e);\n    }\n    \n    // 5. 파일 시스템 접근 모니터링\n    try {\n        var File = Java.use(\"java.io.File\");\n        File.$init.overload('java.lang.String').implementation = function(pathname) {\n            if (pathname.includes(\"data/data\") || pathname.includes(\"sdcard\")) {\n                console.log(\"[File] 파일 접근: \" + pathname);\n            }\n            return this.$init(pathname);\n        };\n    } catch (e) {\n        console.log(\"[-]",
                "File 후킹 실패: \" + e);\n    }\n});\n```\n\n#### Frida 자동화 스크립트\n```python\n#!/usr/bin/env python3\n# frida_android_analyzer.py\n\nimport frida\nimport json\nimport time\nimport threading\nimport argparse\n\nclass AndroidSecurityAnalyzer:\n    def __init__(self, package_name, script_path):\n        self.package_name = package_name\n        self.script_path = script_path\n        self.device = frida.get_usb_device()\n        self.session = None\n        self.script = None\n        self.logs = []\n        \n    def on_message(self, message, data):\n        \"\"\"메시지 핸들러\"\"\"\n        if message['type'] = = 'send':\n            log_entry = {\n                'timestamp': time.time(),\n                'payload': message['payload']\n            }\n            self.logs.append(log_entry)\n            print(f\"[{time.strftime('%H:%M:%S')}] {message['payload']}\")\n        elif message['type'] =",
                "= 'error':\n            print(f\"[ERROR] {message['description']}\")\n    \n    def start_analysis(self):\n        \"\"\"분석 시작\"\"\"\n        try:\n            # 앱이 실행 중인지 확인\n            try:\n                self.session = self.device.attach(self.package_name)\n            except frida.ProcessNotFoundError:\n                print(f\"앱 실행 중... ({self.package_name})\")\n                pid = self.device.spawn([self.package_name])\n                self.device.resume(pid)\n                time.sleep(2)\n                self.session = self.device.attach(pid)\n            \n            # 스크립트 로드\n            with open(self.script_path, 'r', encoding='utf-8') as f:\n                script_code = f.read()\n            \n            self.script = self.session.create_script(script_code)\n            self.script.on('message', self.on_message)\n            self.script.load()\n            \n            print(f\"[+] {self.package_name}에 연결됨\")\n            print(\"[+] 보안 분석 시작...\")\n            \n        except Exception as e:\n            print(f\"[-] 연결 실패: {e}\")\n    \n    def stop_analysis(self):\n        \"\"\"분석 중지 및 리포트 생성\"\"\"\n        if self.script:\n            self.script.unload()\n        if self.session:\n            self.session.detach()\n        \n        # 분석 결과 저장\n        report = {\n            'package_name': self.package_name,\n            'analysis_duration': time.time(),\n            'total_logs': len(self.logs),\n            'logs': self.logs\n        }\n        \n        report_file = f\"frida_report_{self.package_name}_{int(time.time())}.json\"\n        with open(report_file, 'w', encoding='utf-8') as f:\n            json.dump(report, f, indent=2, ensure_ascii=False)\n        \n        print(f\"[+] 분석 완료.",
                "리포트: {report_file}\")\n        return report\n\ndef main():\n    parser = argparse.ArgumentParser(description='Android 앱 보안 분석')\n    parser.add_argument('package', help='분석할 앱 패키지명')\n    parser.add_argument('--script', default='android_security_hooks.js', help='Frida 스크립트 파일')\n    parser.add_argument('--duration', type=int, default=300, help='분석 시간(초)')\n    \n    args = parser.parse_args()\n    \n    analyzer = AndroidSecurityAnalyzer(args.package, args.script)\n    analyzer.start_analysis()\n    \n    try:\n        print(f\"{args.duration}초 동안 분석 실행 중...\")\n        time.sleep(args.duration)\n    except KeyboardInterrupt:\n        print(\"\\n분석을 중단합니다...\")\n    \n    analyzer.stop_analysis()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### 3. Drozer 설정\n\n#### 설치\n```bash\n# Drozer 설치 (Python 2.7 필요)\npip2 install drozer\n\n# 또는 Docker 사용\ndocker pull fsecurelabs/drozer\n```\n\n#### Drozer 에이전트 설치\n```bash\n# APK 다운로드 및 설치\nwget https://github.com/FSecureLABS/drozer/releases/download/2.4.4/drozer-agent-2.4.4.apk\nadb install drozer-agent-2.4.4.apk\n\n# 포트 포워딩\nadb forward tcp:31415 tcp:31415\n```\n\n####",
                "Drozer 분석 스크립트\n```bash\n#!/bin/bash\n# run_drozer.sh\n\nPACKAGE_NAME=\"$1\"\nOUTPUT_DIR=\"drozer_reports\"\n\nmkdir -p $OUTPUT_DIR\n\necho \"Drozer 분석 시작: $PACKAGE_NAME\"\n\n# Drozer 세션 시작 및 분석 수행\ndrozer console connect --server 127.0.0.1:31415 <<EOF\n# 패키지 정보 조회\nrun app.package.info -a $PACKAGE_NAME > $OUTPUT_DIR/package_info.txt\n\n# Attack Surface 분석\nrun app.package.attacksurface $PACKAGE_NAME > $OUTPUT_DIR/attack_surface.txt\n\n# Activity 분석\nrun app.activity.info -a $PACKAGE_NAME > $OUTPUT_DIR/activities.txt\n\n# Service 분석\nrun app.service.info -a $PACKAGE_NAME > $OUTPUT_DIR/services.txt\n\n# Broadcast Receiver 분석\nrun app.broadcast.info -a $PACKAGE_NAME > $OUTPUT_DIR/receivers.txt\n\n# Content Provider 분석\nrun app.provider.info -a $PACKAGE_NAME > $OUTPUT_DIR/providers.txt\nrun app.provider.finduri $PACKAGE_NAME > $OUTPUT_DIR/provider_uris.txt\n\n# Intent 분석\nrun scanner.provider.finduris -a $PACKAGE_NAME > $OUTPUT_DIR/intent_analysis.txt\n\n# 권한 분석\nrun scanner.misc.readablefiles --path /data/data/$PACKAGE_NAME > $OUTPUT_DIR/readable_files.txt\n\nexit\nEOF\n\necho \"Drozer 분석 완료. 결과: $OUTPUT_DIR/\"\n```\n\n---\n\n## 네트워크 분석 환경\n\n### 1. OWASP ZAP 설정\n\n####",
                "Docker 실행\n```bash\n# ZAP 헤드리스 모드 실행\ndocker run -t -p 8080:8080 \\\n    -v $(pwd)/zap_reports:/zap/wrk/:rw \\\n    -i zaproxy/zap-stable zap.sh \\\n    -daemon -host 0.0.0.0 -port 8080 \\\n    -config api.addrs.addr.name=.* \\\n    -config api.addrs.addr.regex=true\n\n# ZAP GUI 모드 (데스크톱 환경)\ndocker run -it -p 8080:8080 \\\n    -v $(pwd)/zap_reports:/zap/wrk/:rw \\\n    -e DISPLAY=$DISPLAY \\\n    -v /tmp/.X11-unix:/tmp/.X11-unix \\\n    zaproxy/zap-stable zap.sh\n```\n\n#### Android 기기 프록시 설정\n```python\n#!/usr/bin/env python3\n# android_zap_proxy.py\n\nimport time\nimport json\nfrom zapv2 import ZAPv2\nimport subprocess\n\nclass AndroidZAPProxy:\n    def __init__(self, zap_host='localhost', zap_port=8080):\n        self.zap = ZAPv2(proxies={\n            'http': f'http://{zap_host}:{zap_port}',\n            'https': f'https://{zap_host}:{zap_port}'\n        })\n        self.zap_host = zap_host\n        self.zap_port = zap_port\n    \n    def setup_android_proxy(self):\n        \"\"\"Android 기기 프록시 설정\"\"\"\n        print(\"Android 기기 프록시 설정 중...\")\n        \n        # CA 인증서 추출\n        cert = self.zap.core.rootcert()\n        with open('zap_root_ca.crt', 'wb') as f:\n            f.write(cert)\n        \n        # Android 기기에 인증서 설치\n        subprocess.run(['adb', 'push', 'zap_root_ca.crt', '/sdcard/'])\n        \n        print(\"1. Android 설정 > Wi-Fi > 네트워크 수정\")\n        print(f\"2. 프록시: 수동, 호스트: {self.zap_host}, 포트: {self.zap_port}\")\n        print(\"3.",
                "설정 > 보안 > 인증서 설치 > SD카드에서 zap_root_ca.crt 설치\")\n        \n        input(\"프록시 설정 완료 후 Enter를 누르세요...\")\n    \n    def configure_android_rules(self):\n        \"\"\"Android 앱 테스트용 ZAP 규칙 설정\"\"\"\n        # Passive scan rules 활성화\n        self.zap.pscan.enable_all_scanners()\n        \n        # Active scan policy 설정\n        policy_name = \"Android-App-Policy\"\n        self.zap.ascan.new_scan_policy(policy_name)\n        \n        # Android 관련 스캔 규칙 활성화\n        android_rules = [\n            '10055',  # Persistent XSS (Attack)\n            '40012',  # Cross Site Scripting (Reflected)\n            '40014',  # Cross Site Scripting (Persistent)\n            '40016',  # Cross Site Scripting (Persistent) - Prime\n            '40017',  # Cross Site Scripting (Persistent) - Spider\n            '40018',  # SQL Injection\n            '90019',  # Server Side Code Injection\n            '90020',  # Remote OS Command Injection\n        ]\n        \n        for rule_id in android_rules:\n            try:\n                self.zap.ascan.set_scanner_alert_threshold(rule_id, 'LOW')\n                self.zap.ascan.enable_scanners(rule_id)\n            except:\n                pass\n    \n    def start_monitoring(self, target_package):\n        \"\"\"모니터링 시작\"\"\"\n        print(f\"앱 모니터링 시작: {target_package}\")\n        \n        # 앱 실행\n        subprocess.run(['adb', 'shell', 'monkey', '-p', target_package, '1'])\n        \n        # Spider 실행\n        target_url = \"https://api.yourapp.com\"  # 실제 API URL로 변경\n        print(f\"Spider 시작: {target_url}\")\n        spider_id = self.zap.spider.scan(target_url)\n        \n        while int(self.zap.spider.status(spider_id)) < 100:\n            print(f\"Spider 진행률: {self.zap.spider.status(spider_id)}%\")\n            time.sleep(10)\n        \n        print(\"Spider 완료\")\n    \n    def run_security_scan(self, target_url):\n        \"\"\"보안 스캔 실행\"\"\"\n        print(f\"보안 스캔 시작: {target_url}\")\n        \n        # Active Scan 시작\n        scan_id = self.zap.ascan.scan(target_url)\n        \n        while int(self.zap.ascan",
                ".status(scan_id)) < 100:\n            progress = self.zap.ascan.status(scan_id)\n            print(f\"Active Scan 진행률: {progress}%\")\n            time.sleep(30)\n        \n        print(\"보안 스캔 완료\")\n    \n    def generate_report(self, format='json'):\n        \"\"\"리포트 생성\"\"\"\n        alerts = self.zap.core.alerts()\n        \n        if format == 'json':\n            report = {\n                'scan_date': time.strftime('%Y-%m-%d %H:%M:%S'),\n                'total_alerts': len(alerts),\n                'high_risk': len([a for a in alerts if a['risk'] =",
                "= 'High']),\n                'medium_risk': len([a for a in alerts if a['risk'] = = 'Medium']),\n                'low_risk': len([a for a in alerts if a['risk'] = = 'Low']),\n                'alerts': alerts\n            }\n            \n            with open('android_zap_report.json', 'w', encoding='utf-8') as f:\n                json.dump(report, f, indent=2, ensure_ascii=False)\n            \n            return report\n        elif format == 'html':\n            html_report = self.zap.core.htmlreport()\n            with open('android_zap_report.html', 'w', encoding='utf-8') as f:\n                f.write(html_report)\n            return html_report\n\n# 사용 예\nif __name__ == \"__main__\":\n    proxy = AndroidZAPProxy()\n    proxy.setup_android_proxy()\n    proxy.configure_android_rules()\n    \n    target_package = \"com.yourapp.package\"\n    target_api = \"https://api.yourapp.com\"\n    \n    proxy.start_monitoring(target_package)\n    proxy.run_security_scan(target_api)\n    \n    report = proxy.generate_report('json')\n    print(f\"스캔 완료. 총 {report['total_alerts']}개 알림 발견\")\n```\n\n### 2. Charles Proxy 대체 도구 (mitmproxy)\n\n#### 설치 및 설정\n```bash\n# mitmproxy 설치\npip3 install mitmproxy\n\n# Android용 인증서 설정\nmitmdump --set confdir=~/.mitmproxy\n```\n\n####",
                "Android 전용 mitmproxy 스크립트\n```python\n# android_mitm_monitor.py\nimport json\nimport re\nfrom mitmproxy import http, ctx\nfrom urllib.parse import urlparse, parse_qs\n\nclass AndroidSecurityMonitor:\n    def __init__(self):\n        self.api_calls = []\n        self.sensitive_data = []\n        self.auth_tokens = set()\n        \n    def request(self, flow: http.HTTPFlow) -> None:\n        \"\"\"요청 분석\"\"\"\n        # API 키 검출\n        api_key_patterns = [\n            r'api[_-]?key',\n            r'access[_-]?token',\n            r'auth[_-]?token',\n            r'bearer',\n            r'jwt'\n        ]\n        \n        # 헤더에서 민감정보 검출\n        for name, value in flow.request.headers.items():\n            for pattern in api_key_patterns:\n                if re.search(pattern, name.lower()):\n                    self.sensitive_data.append({\n                        'type': 'sensitive_header',\n                        'url': flow.request.pretty_url,\n                        'header_name': name,\n                        'header_value': value[:10] + '...',\n                        'method': flow.request.method\n                    })\n        \n        # URL 파라미터에서 민감정보 검출\n        parsed_url = urlparse(flow.request.pretty_url)\n        query_params = parse_qs(parsed_url.query)\n        \n        for param_name in query_params:\n            for pattern in api_key_patterns:\n                if re.search(pattern, param_name.lower()):\n                    self.sensitive_data.append({\n                        'type': 'sensitive_url_param',\n                        'url': flow.request.pretty_url,\n                        'param_name': param_name,\n                        'param_value': str(query_params[param_name])[:10] + '...'\n                    })\n        \n        # POST 데이터 분석\n        if flow.request.method == 'POST' and flow.request.content:\n            try:\n                content_str = flow.request.content.decode('utf-8')\n                \n                # JSON 데이터 분석\n                if 'application/json' in flow.reques",
                "t.headers.get('content-type', ''):\n                    data = json.loads(content_str)\n                    for key in data:\n                        for pattern in api_key_patterns:\n                            if re.search(pattern, key.lower()):\n                                self.sensitive_data.append({\n                                    'type': 'sensitive_json_data',\n                                    'url': flow.request.pretty_url,\n                                    'key': key,\n                                    'value': str(data[key])[:10] + '...'\n                                })\n                \n                # Form 데이터 분석\n                elif 'application/x-www-form-urlencoded' in flow.request.headers.get('content-type', ''):\n                    form_data = parse_qs(content_str)\n                    for key in form_data:\n                        for pattern in api_key_patterns:\n                            if re.search(pattern, key.lower()):\n                                self.sensitive_data.append({\n                                    'type': 'sensitive_form_data',\n                                    'url': flow.request.pretty_url,\n                                    'key': key,\n                                    'value': str(form_data[key])[:10] + '...'\n                                })\n            except:\n                pass\n    \n    def response(self, flow: http.HTTPFlow) -> None:\n        \"\"\"응답 분석\"\"\"\n        if flow.response and flow.response.status_code == 200:\n            try:\n                # JSON 응답에서 토큰 추출\n                if 'application/json' in flow.response.headers.get('content-type', ''):\n                    response_data = json.loads(flow.response.text)\n                    \n                    token_keys = ['token', 'access_token', 'jwt', 'auth_token', 'bearer']\n                    for key in token_keys:\n                        if key in response_data:\n                            token = response_data[key]\n                            sel",
                "f.auth_tokens.add(token[:20] + '...')\n                            \n                            self.api_calls.append({\n                                'url': flow.request.pretty_url,\n                                'method': flow.request.method,\n                                'response_contains_token': True,\n                                'token_key': key,\n                                'response_size': len(flow.response.content),\n                                'status_code': flow.response.status_code\n                            })\n                \n                # 헤더에서 토큰 추출\n                for name, value in flow.response.headers.items():\n                    if 'token' in name.lower() or 'auth' in name.lower():\n                        self.auth_tokens.add(value[:20] + '...')\n                        \n            except:\n                # JSON이 아닌 응답\n                self.api_calls.append({\n                    'url': flow.request.pretty_url,\n                    'method': flow.request.method,\n                    'response_contains_token': False,\n                    'response_size': len(flow.response.content) if flow.response.content else 0,\n                    'status_code': flow.response.status_code\n                })\n    \n    def done(self):\n        \"\"\"분석 완료 시 리포트 생성\"\"\"\n        report = {\n            'analysis_summary': {\n                'total_requests': len(self.api_calls),\n                'sensitive_data_findings': len(self.sensitive_data),\n                'unique_tokens_found': len(self.auth_tokens)\n            },\n            'api_calls': self.api_calls,\n            'sensitive_data': self.sensitive_data,\n            'auth_tokens': list(self.auth_tokens),\n            'security_recommendations': []\n        }\n        \n        # 보안 권고사항 생성\n        if self.sensitive_data:\n            report['security_recommendations'].append(\n                \"민감한 데이터가 URL 파라미터나 헤더에 노출되고 있습니다.",
                "HTTPS POST body 사용을 권장합니다.\"\n            )\n        \n        if len(self.auth_tokens) > 3:\n            report['security_recommendations'].append(\n                \"다수의 인증 토큰이 발견되었습니다. 토큰 재사용 및 만료 정책을 검토하세요.\"\n            )\n        \n        with open('android_mitm_security_report.json', 'w', encoding='utf-8') as f:\n            json.dump(report, f, indent=2, ensure_ascii=False)\n        \n        ctx.log.info(f\"Android 보안 분석 완료:\")\n        ctx.log.info(f\"- 총 요청: {len(self.api_calls)}개\")\n        ctx.log.info(f\"- 민감정보 발견: {len(self.sensitive_data)}건\")\n        ctx.log.info(f\"- 토큰 발견: {len(self.auth_tokens)}개\")\n\naddons = [AndroidSecurityMonitor()]\n```\n\n---\n\n## 자동화 테스트 환경\n\n### 1. GitHub Actions 워크플로우\n\n```yaml\n# .github/workflows/android-security-test.yml\nname: Android Security Testing\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name:",
                "Set up JDK 11\n      uses: actions/setup-java@v3\n      with:\n        java-version: '11'\n        distribution: 'temurin'\n    \n    - name: Setup Android SDK\n      uses: android-actions/setup-android@v2\n    \n    - name: Cache Gradle packages\n      uses: actions/cache@v3\n      with:\n        path: |\n          ~/.gradle/caches\n          ~/.gradle/wrapper\n        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}\n    \n    - name: Grant execute permission for gradlew\n      run: chmod +x gradlew\n    \n    - name: Build APK\n      run: ./gradlew assembleRelease\n    \n    - name: Install Security Tools\n      run: |\n        pip3 install qark\n        docker pull opensecurity/mobsf\n    \n    - name: Run QARK Analysis\n      run: |\n        mkdir -p security-reports\n        qark --apk app/build/outputs/apk/release/app-release-unsigned.apk \\\n             --report-type json \\\n             --report-dir security-reports/\n    \n    - name: Run MobSF Analysis\n      run: |\n        docker run --rm \\\n          -v $(pwd)/app/build/outputs/apk/release:/app:ro \\\n          -v $(pwd)/security-reports:/reports:rw \\\n          opensecurity/mobsf:latest \\\n          python3 /home/mobsf/Mobile-Security-Framework-MobSF/manage.py \\\n          scan /app/app-release-unsigned.apk\n    \n    - name: Run Gradle Security Tasks\n      run: |\n        ./gradlew dependencyCheckAnalyze\n        ./gradlew spotbugsMain\n        ./gradlew detekt\n    \n    - name: Generate Security Report\n      run: |\n        python3 scripts/generate_android_security_report.py \\\n          --qark security-reports/ \\\n          --mobsf security-reports/ \\\n          --dependency-check build/reports/dependencyCheck/ \\\n          --spotbugs build/reports/spotbugs/ \\\n          --detekt build/reports/detekt/ \\\n          --output security-reports/comprehensive_report.html\n    \n    - name: Upload Security Reports\n      uses: actions/upload-artifact@v3\n      with:\n        name: android-security-reports\n        path: s",
                "ecurity-reports/\n    \n    - name: Security Gate Check\n      run: |\n        python3 scripts/security_gate_check.py \\\n          --report security-reports/comprehensive_report.json \\\n          --max-high-issues 0 \\\n          --max-medium-issues 5\n    \n    - name: Comment PR with Results\n      if: github.event_name == 'pull_request'\n      uses: actions/github-script@v6\n      with:\n        script: |\n          const fs = require('fs');\n          try {\n            const report = JSON.parse(fs.readFileSync('security-reports/comprehensive_report.json'));\n            const high = report.summary.high_risk_issues || 0;\n            const medium = report.summary.medium_risk_issues || 0;\n            \n            const body = `## 🔒 Android 보안 스캔 결과\n            \n            - 🔴 높은 위험도: ${high}개\n            - 🟠 중간 위험도: ${medium}개\n            - 📊 전체 리포트: [상세 보기](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})\n            \n            ${high > 0 ?",
                "'⚠️ 높은 위험도 이슈가 발견되었습니다.",
                "수정이 필요합니다.' : '✅ 심각한 보안 이슈가 발견되지 않았습니다.'}`;\n            \n            github.rest.issues.createComment({\n              issue_number: context.issue.number,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              body: body\n            });\n          } catch (error) {\n            console.log('리포트 파일을 찾을 수 없습니다.');\n          }\n```\n\n### 2. 로컬 자동화 스크립트\n\n```bash\n#!/bin/bash\n# comprehensive_android_security_test.sh\n\nset -e\n\nPROJECT_DIR=\"$1\"\nAPK_PATH=\"$2\"\nREPORT_DIR=\"android_security_reports_$(date +%Y%m%d_%H%M%S)\"\n\nif [ -z \"$PROJECT_DIR\" ] || [ -z \"$APK_PATH\" ]; then\n    echo \"사용법: $0 <프로젝트_경로> <APK_파일_경로>\"\n    exit 1\nfi\n\necho \"🔒 Android 종합 보안 테스트 시작\"\necho \"프로젝트: $PROJECT_DIR\"\necho \"APK: $APK_PATH\"\necho \"리포트 디렉토리: $REPORT_DIR\"\n\n# 리포트 디렉토리 생성\nmkdir -p $REPORT_DIR\n\n# 1. APK 기본 정보 추출\necho \"1️⃣ APK 기본 정보 분석 중...\"\naapt dump badging \"$APK_PATH\" > \"$REPORT_DIR/apk_info.txt\"\naapt dump permissions \"$APK_PATH\" > \"$REPORT_DIR/permissions.txt\"\n\n# 2. QARK 정적 분석\necho \"2️⃣ QARK 정적 분석 중...\"\nqark --apk \"$APK_PATH\" \\\n     --report-type json \\\n     --report-dir \"$REPORT_DIR/qark/\"\n\n# 3. MobSF 분석\necho \"3️⃣ MobSF 종합 분석 중...\"\ndocker run --rm \\\n    -v \"$(realpath $APK_PATH):/app/app.apk:ro\" \\\n    -v \"$(pwd)/$REPORT_DIR:/reports:rw\" \\\n    opensecurity/mobsf:latest \\\n    python3 /home/mobsf/Mobile-Security-Framework-MobSF/manage.py \\\n    scan /app/app.apk\n\n# 4. APK 디컴파일 및 소스 분석\necho \"4️⃣ APK 디컴파일 및 소스 분석 중...\"\nDECOMPILE_DIR=\"$REPORT_DIR/decompiled\"\nmkdir -p \"$DECOMPILE_DIR\"\n\n# APKTool로 디컴파일\napktool d \"$APK_PATH\" -o \"$DECOMPILE_DIR/apktool\"\n\n# JADX로 Java 소스 추출\njadx -d \"$DECOMPILE_DIR/jadx\" \"$APK_PATH\"\n\n# 5. 민감정보 패턴 검색\necho \"5️⃣ 민감정보 패턴 검색 중...\"\npython3 << EOF\nimport os\nimport re\nimport json\n\npatterns = {\n    'api_keys': [\n        r'api[_-]?key\\s*[:=]\\s*[\"\\']([^\"\\']+)[\"\\']',\n        r'secret[_-]?key\\s*[:=]\\s*[\"\\']([^\"\\']+)[\"\\']',\n    ],\n    'urls': [\n        r'https?://[^\\s\\'\"<>]+',\n    ],\n    'crypto': [\n        r'AES|DES|RSA|MD5|SHA1|SHA256',\n        r'javax\\.cr",
                "ypto\\.',\n    ],\n    'hardcoded_passwords': [\n        r'password\\s*[:=]\\s*[\"\\']([^\"\\']+)[\"\\']',\n        r'passwd\\s*[:=]\\s*[\"\\']([^\"\\']+)[\"\\']',\n    ]\n}\n\nresults = {}\nsource_dir = \"$DECOMPILE_DIR/jadx\"\n\nfor root, dirs, files in os.walk(source_dir):\n    for file in files:\n        if file.endswith('.java'):\n            file_path = os.path.join(root, file)\n            try:\n                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n                    content = f.read()\n                    \n                for category, pattern_list in patterns.items():\n                    if category not in results:\n                        results[category] = []\n                        \n                    for pattern in pattern_list:\n                        matches = re.findall(pattern, content, re.IGNORECASE)\n                        for match in matches:\n                            results[category].append({\n                                'file': file_path.replace(source_dir, ''),\n                                'match': match if isinstance(match, str) else match[0] if match else '',\n                                'pattern': pattern\n                            })\n            except:\n                pass\n\nwith open('$REPORT_DIR/sensitive_data_scan.json', 'w') as f:\n    json.dump(results, f, indent=2)\n\nprint(f\"민감정보 스캔 완료:\")\nfor category, items in results.items():\n    print(f\"  {category}: {len(items)}개 발견\")\nEOF\n\n# 6. 권한 분석\necho \"6️⃣ 권한 위험도 분석 중...\"\npython3 << EOF\nimport xml.etree.ElementTree as ET\nimport json\n\n# 위험한 권한 목록\ndangerous_permissions = {\n    'android.permission.READ_EXTERNAL_STORAGE': 'high',\n    'android.permission.WRITE_EXTERNAL_STORAGE': 'high',\n    'android.permission.CAMERA': 'high',\n    'android.permission.RECORD_AUDIO': 'high',\n    'android.permission.ACCESS_FINE_LOCATION': 'high',\n    'android.permission.ACCESS_COARSE_LOCATION': 'medium',\n    'android.permission.READ_CONTACTS': 'high',\n    'android.permission.WRITE_CONTACTS': 'high',\n    'andro",
                "id.permission.READ_PHONE_STATE': 'medium',\n    'android.permission.CALL_PHONE': 'high',\n    'android.permission.SEND_SMS': 'high',\n    'android.permission.RECEIVE_SMS': 'medium',\n}\n\ntry:\n    # AndroidManifest.xml 파싱\n    manifest_path = '$DECOMPILE_DIR/apktool/AndroidManifest.xml'\n    tree = ET.parse(manifest_path)\n    root = tree.getroot()\n    \n    permissions = []\n    for permission in root.findall('.//uses-permission'):\n        perm_name = permission.get('{http://schemas.android.com/apk/res/android}name')\n        if perm_name:\n            risk_level = dangerous_permissions.get(perm_name, 'low')\n            permissions.append({\n                'name': perm_name,\n                'risk_level': risk_level\n            })\n    \n    permission_report = {\n        'total_permissions': len(permissions),\n        'high_risk': len([p for p in permissions if p['risk_level'] =",
                "= 'high']),\n        'medium_risk': len([p for p in permissions if p['risk_level'] = = 'medium']),\n        'low_risk': len([p for p in permissions if p['risk_level'] =",
                "= 'low']),\n        'permissions': permissions\n    }\n    \n    with open('$REPORT_DIR/permission_analysis.json', 'w') as f:\n        json.dump(permission_report, f, indent=2)\n    \n    print(f\"권한 분석 완료: 총 {len(permissions)}개 권한\")\n    print(f\"  높은 위험: {permission_report['high_risk']}개\")\n    print(f\"  중간 위험: {permission_report['medium_risk']}개\")\n    \nexcept Exception as e:\n    print(f\"권한 분석 실패: {e}\")\nEOF\n\n# 7. 종합 리포트 생성\necho \"7️⃣ 종합 리포트 생성 중...\"\npython3 << 'EOF'\nimport json\nimport os\nfrom datetime import datetime\n\nreport_dir = os.environ.get('REPORT_DIR')\napk_path = os.environ.get('APK_PATH')\n\n# 종합 리포트 생성\ncomprehensive_report = {\n    'metadata': {\n        'apk_path': apk_path,\n        'analysis_date': datetime.now().isoformat(),\n        'tools_used': ['QARK', 'MobSF', 'APKTool', 'JADX', 'Custom Scripts']\n    },\n    'summary': {\n        'total_issues': 0,\n        'high_risk_issues': 0,\n        'medium_risk_issues': 0,\n        'low_risk_issues': 0\n    },\n    'detailed_results': {}\n}\n\n# 각 도구의 결과 통합\ntry:\n    # QARK 결과\n    qark_files = [f for f in os.listdir(f'{report_dir}/qark') if f.endswith('.json')]\n    if qark_files:\n        with open(f'{report_dir}/qark/{qark_files[0]}') as f:\n            qark_data = json.load(f)\n            comprehensive_report['detailed_results']['qark'] = qark_data\n    \n    # 권한 분석 결과\n    if os.path.exists(f'{report_dir}/permission_analysis.json'):\n        with open(f'{report_dir}/permission_analysis.json') as f:\n            perm_data = json.load(f)\n            comprehensive_report['detailed_results']['permissions'] = perm_data\n            comprehensive_report['summary']['high_risk_issues'] += perm_data['high_risk']\n            comprehensive_report['summary']['medium_risk_issues'] += perm_data['medium_risk']\n    \n    # 민감정보 스캔 결과\n    if os.path.exists(f'{report_dir}/sensitive_data_scan.json'):\n        with open(f'{report_dir}/sensitive_data_scan.json') as f:\n            sensitive_data = json.load(f)\n            comprehensive_report['detailed_results']",
                "['sensitive_data'] = sensitive_data\n            \n            for category, items in sensitive_data.items():\n                if category in ['api_keys', 'hardcoded_passwords']:\n                    comprehensive_report['summary']['high_risk_issues'] += len(items)\n                else:\n                    comprehensive_report['summary']['medium_risk_issues'] += len(items)\n    \n    comprehensive_report['summary']['total_issues'] = (\n        comprehensive_report['summary']['high_risk_issues'] + \n        comprehensive_report['summary']['medium_risk_issues'] + \n        comprehensive_report['summary']['low_risk_issues']\n    )\n    \n    # 리포트 저장\n    with open(f'{report_dir}/comprehensive_report.json', 'w', encoding='utf-8') as f:\n        json.dump(comprehensive_report, f, indent=2, ensure_ascii=False)\n    \n    print(\"종합 리포트 생성 완료\")\n    print(f\"총 이슈: {comprehensive_report['summary']['total_issues']}개\")\n    print(f\"  높은 위험: {comprehensive_report['summary']['high_risk_issues']}개\")\n    print(f\"  중간 위험: {comprehensive_report['summary']['medium_risk_issues']}개\")\n    \nexcept Exception as e:\n    print(f\"리포트 생성 중 오류: {e}\")\nEOF\n\necho \"✅ Android 보안 테스트 완료!\"\necho \"📊 리포트 위치: $REPORT_DIR/\"\necho \"\"\necho \"주요 파일:\"\necho \"  - comprehensive_report.json: 종합 결과\"\necho \"  - permission_analysis.json: 권한 분석\"\necho \"  - sensitive_data_scan.json: 민감정보 스캔\"\necho \"  - qark/: QARK 분석 결과\"\necho \"  - decompiled/: 디컴파일된 소스\"\n\n# 보안 점수 계산 및 출력\npython3 -c \"\nimport json\ntry:\n    with open('$REPORT_DIR/comprehensive_report.json') as f:\n        data = json.load(f)\n    high = data['summary']['high_risk_issues']\n    medium = data['summary']['medium_risk_issues']\n    \n    # 간단한 보안 점수 계산 (100점 만점)\n    score = max(0, 100 - (high * 10 + medium * 3))\n    \n    print(f'')\n    print(f'🏆 보안 점수: {score}/100')\n    if score >= 90:\n        print('✅ 우수한 보안 상태입니다.')\n    elif score >= 70:\n        print('⚠️ 일부 보안 개선이 필요합니다.')\n    else:\n        print('❌ 심각한 보안 문제가 있습니다.",
                "즉시 수정이 필요합니다.')\nexcept Exception as e:\n    print('보안 점수 계산 실패')\n\"\n```\n\n---\n\n## CI/CD 통합\n\n###",
                "1. Jenkins Pipeline (Android)\n\n```groovy\n// Jenkinsfile\npipeline {\n    agent {\n        label 'android-slave'\n    }\n    \n    environment {\n        ANDROID_HOME = '/opt/android-sdk'\n        JAVA_HOME = '/usr/lib/jvm/java-11-openjdk'\n    }\n    \n    stages {\n        stage('Checkout') {\n            steps {\n                checkout scm\n            }\n        }\n        \n        stage('Build') {\n            steps {\n                sh './gradlew clean assembleRelease'\n            }\n        }\n        \n        stage('Security Analysis') {\n            parallel {\n                stage('Static Analysis') {\n                    steps {\n                        script {\n                            // QARK 분석\n                            sh '''\n                                mkdir -p security-reports/qark\n                                qark --apk app/build/outputs/apk/release/app-release-unsigned.apk \\\n                                     --report-type json \\\n                                     --report-dir security-reports/qark/\n                            '''\n                            \n                            // SpotBugs 분석\n                            sh './gradlew spotbugsMain'\n                            \n                            // Dependency Check\n                            sh './gradlew dependencyCheckAnalyze'\n                        }\n                    }\n                }\n                \n                stage('MobSF Analysis') {\n                    steps {\n                        sh '''\n                            docker run --rm \\\n                                -v $(pwd)/app/build/outputs/apk/release:/app:ro \\\n                                -v $(pwd)/security-reports:/reports:rw \\\n                                opensecurity/mobsf:latest \\\n                                python3 manage.py scan /app/app-release-unsigned.apk\n                        '''\n                    }\n                }\n                \n                stage('Dynamic Analysis Setup') {",
                "when {\n                        expression { params.ENABLE_DYNAMIC_ANALYSIS }\n                    }\n                    steps {\n                        sh '''\n                            # 에뮬레이터 시작\n                            $ANDROID_HOME/emulator/emulator -avd SecurityTestDevice -no-window -no-audio &\n                            adb wait-for-device\n                            \n                            # Frida 설정\n                            adb push frida-server /data/local/tmp/\n                            adb shell \"chmod 755 /data/local/tmp/frida-server\"\n                            adb shell \"/data/local/tmp/frida-server &\"\n                            \n                            # 앱 설치 및 테스트\n                            adb install app/build/outputs/apk/release/app-release-unsigned.apk\n                        '''\n                    }\n                }\n            }\n        }\n        \n        stage('Report Generation') {\n            steps {\n                sh '''\n                    python3 scripts/generate_comprehensive_report.py \\\n                        --qark security-reports/qark/ \\\n                        --mobsf security-reports/ \\\n                        --spotbugs build/reports/spotbugs/ \\\n                        --dependency-check build/reports/dependencyCheck/ \\\n                        --output security-reports/final_report.html\n                '''\n                \n                publishHTML([\n                    allowMissing: false,\n                    alwaysLinkToLastBuild: true,\n                    keepAll: true,\n                    reportDir: 'security-reports',\n                    reportFiles: 'final_report.html',\n                    reportName: 'Android Security Report'\n                ])\n            }\n        }\n        \n        stage('Security Gate') {\n            steps {\n                script {\n                    def securityReport = readJSON file: 'security-reports/summary.json'\n                    def highIssues",
                "= securityReport.high_risk_issues ?: 0\n                    def mediumIssues = securityReport.medium_risk_issues ?: 0\n                    \n                    if (highIssues > 0) {\n                        error(\"높은 위험도 보안 이슈 ${highIssues}개 발견. 빌드를 중단합니다.\")\n                    }\n                    \n                    if (mediumIssues > 10) {\n                        unstable(\"중간 위험도 보안 이슈가 너무 많습니다",
                "(${mediumIssues}개)\")\n                    }\n                    \n                    echo \"보안 게이트 통과: 높은 위험 ${highIssues}개, 중간 위험 ${mediumIssues}개\"\n                }\n            }\n        }\n    }\n    \n    post {\n        always {\n            archiveArtifacts artifacts: 'security-reports/**/*', allowEmptyArchive: true\n            \n            // 에뮬레이터 정리\n            sh '''\n                adb emu kill || true\n                pkill -f emulator || true\n            '''\n        }\n        success {\n            slackSend(\n                color: 'good',\n                message: \":white_check_mark: Android 보안 테스트 성공: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\"\n            )\n        }\n        failure {\n            slackSend(\n                color: 'danger',\n                message: \":x: Android 보안 테스트 실패: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\"\n            )\n        }\n    }\n}\n```\n\n### 2. GitLab CI/CD\n\n```yaml\n# .gitlab-ci.yml\nstages:\n  - build\n  - security-test\n  - dynamic-test\n  - report\n  - deploy\n\nvariables:\n  GRADLE_OPTS: \"-Dorg.gradle.daemon=false\"\n  GRADLE_USER_HOME: \"$CI_PROJECT_DIR/.gradle\"\n\ncache:\n  paths:\n    - .gradle/\n\nbefore_script:\n  - export GRADLE_USER_HOME=$CI_PROJECT_DIR/.gradle\n  - chmod +x ./gradlew\n\nbuild_apk:\n  stage: build\n  image: openjdk:11-jdk\n  before_script:\n    - apt-get update -qq && apt-get install -y -qq git curl unzip\n    - curl -sSL https://dl.google.com/android/repository/commandlinetools-linux-7583922_latest.zip -o tools.zip\n    - unzip tools.zip -d android-sdk\n    - export ANDROID_SDK_ROOT=$PWD/android-sdk\n  script:\n    - ./gradlew assembleRelease\n  artifacts:\n    paths:\n      - app/build/outputs/apk/release/\n    expire_in: 1 hour\n\nstatic_security_analysis:\n  stage: security-test\n  image: python:3.9\n  script:\n    - pip3 install qark\n    - mkdir -p security-reports\n    - qark --apk app/build/outputs/apk/release/app-release-unsigned.apk\n           --report-type json\n           --report-dir security-reports/qark/\n  artifacts:\n    reports:\n      junit",
                ": security-reports/qark/junit.xml\n    paths:\n      - security-reports/\n    expire_in: 1 week\n\nmobsf_analysis:\n  stage: security-test\n  services:\n    - docker:dind\n  script:\n    - docker run --rm\n        -v $CI_PROJECT_DIR/app/build/outputs/apk/release:/app:ro\n        -v $CI_PROJECT_DIR/security-reports:/reports:rw\n        opensecurity/mobsf:latest\n        python3 manage.py scan /app/app-release-unsigned.apk\n  artifacts:\n    paths:\n      - security-reports/\n    expire_in: 1 week\n\ndependency_check:\n  stage: security-test\n  script:\n    - ./gradlew dependencyCheckAnalyze\n  artifacts:\n    reports:\n      junit: build/reports/dependencyCheck/junit.xml\n    paths:\n      - build/reports/dependencyCheck/\n    expire_in: 1 week\n\ndynamic_security_test:\n  stage: dynamic-test\n  image: ubuntu:20.04\n  services:\n    - docker:dind\n  variables:\n    DEBIAN_FRONTEND: noninteractive\n  before_script:\n    - apt-get update -qq\n    - apt-get install -y -qq python3 python3-pip adb docker.io\n    - pip3 install frida-tools\n  script:\n    # 에뮬레이터 시작 (실제 환경에서는 더 복잡한 설정 필요)\n    - echo \"동적 분석은 실제 기기나 에뮬레이터가 필요합니다\"\n    - echo \"현재 단계에서는 스킵합니다\"\n  allow_failure: true\n\ngenerate_comprehensive_report:\n  stage: report\n  image: python:3.9\n  script:\n    - pip3 install jinja2 matplotlib\n    - python3 scripts/generate_comprehensive_report.py\n        --qark security-reports/qark/\n        --mobsf security-reports/\n        --dependency-check build/reports/dependencyCheck/\n        --output security-reports/comprehensive_report.html\n  artifacts:\n    paths:\n      - security-reports/comprehensive_report.html\n    expire_in: 30 days\n  coverage: '/Security",
                "Score: (\\d+)%/'\n\nsecurity_gate_check:\n  stage: report\n  script:\n    - python3 scripts/security_gate_check.py\n        --report security-reports/summary.json\n        --max-high-issues 0\n        --max-medium-issues 5\n    - echo \"보안 게이트 검사 완료\"\n\npages:\n  stage: deploy\n  script:\n    - mkdir public\n    - cp security-reports/comprehensive_report.html public/index.html\n    - cp -r security-reports/ public/\n  artifacts:\n    paths:\n      - public\n  only:\n    - main\n```\n\n이 종합적인 Android 보안 테스트 환경 구성 가이드를 통해 개발팀은 체계적이고 자동화된 보안 검증 프로세스를 구축할 수 있습니다."
            ]
        },
        {
            "filename": "AppSec_질의응답_진행현황.pdf",
            "total_characters": 11587,
            "total_chunks": 8,
            "chunks": [
                "[Page 1]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n1 / 21\nFlitto LLM 시스템  AppSec 질의응답  진행  현황  보고서\n작성일 : 2025 년  1 월  작성자 : AppSec 팀  문서  버전 : v1.0\n📊  전체  진행  현황\n2 0 2 5 - 0 1 - 0 1 \n2 0 2 5 - 0 1 - 0 1 \n2 0 2 5 - 0 1 - 0 2 \n2 0 2 5 - 0 1 - 0 2 \n2 0 2 5 - 0 1 - 0 3 \n2 0 2 5 - 0 1 - 0 3 \n2 0 2 5 - 0 1 - 0 4 \n2 0 2 5 - 0 1 - 0 4 \n2 0 2 5 - 0 1 - 0 5 \n2 0 2 5 - 0 1 - 0 5 \n2 0 2 5 - 0 1 - 0 6 \n질문  1-6 답변  수집\n질문  7-10 답변  작성\n최종  문서  통합\n검토  및  승인\n완료된  질문\n진행  중\n향후  계획\nAppSec 질의응답  진행  타임라인\n진행률\n완료 : 6/10 질문  (60%)\n진행  중 : 4/10 질문  (40%)\n예상  완료일 : 2025 년  8 월  중\n✅  완료된  질문  (1-6 번 )\n질문  1: 시스템  아키텍처  다이어그램\n시스템  구성도\n\n[Page 2]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n2 / 21\nAWS 클라우드\n외부\nPublic Subnet\nPrivate Subnet\n데이터  계층\n모니터링\n모델  저장소\nHTTPS\nPrivate API\n모니터링\n모니터링 모니터링\n위협  탐지보안  검증\n모델  로드 모델  로드\nPrivate HuggingFace모델  버전  관리\nCloudWatch모니터링  & 알림GuardDuty보안  위협  탐지 AWS SCM보안  구성  관리\nElastiCacheRedis번역  캐시  12h TTLDynamoDB짧은  단어  DB Elasticsearch로그  중앙  관리\n내부  로드밸런서\nSTT 서버Transformer 기반GPU EC2 + Docker\n번역  LLM 서버OpenLLM 기반GPU EC2 + Docker\n로드밸런서Application Load Balancer\n웹서버Node.js",
                "PM2CPU+GPU EC2\n클라이언트음성  입력\n주요  컴포넌트\n컴포넌트 기술  스택 역할 보안  정책\n웹서버 Node.js + PM2, EC2\n(CPU+GPU)\n클라이언트  접점 , API 게이트\n웨이\nPublic IP, HTTPS, 세션\n인증\nSTT 서버 Transformer 기반 , Docker, GPU\nEC2 음성 → 텍스트  변환 Private IP, 내부  통신만\n번역  LLM 서버 OpenLLM 파인튜닝 , Docker, GPU\nEC2 텍스트  번역 Private IP, 내부  통신만\nElastiCache Redis 번역  결과  캐싱  (12h TTL) 원문  해시  키 , Private\nDynamoDB NoSQL 짧은  단어  번역  DB 암호화  at rest, 수동  관리\nElasticsearch 로그  관리 중앙  로그  저장 무결성  보호\nHuggingFace Private Hub 모델  버전  관리 IP 제한 , 접근자  권한\n보안  계층\n\n[Page 3]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n3 / 21\n컴플라이언스\nISO 27001\n정보보호  인증\nSecurity Manager\n보안  구성  검증\n위협  탐지\nGuardDuty\n이상  행위  탐지\nCloudWatch\n실시간  모니터링\n접근  제어\nIAM Role\n최소  권한  원칙\nSSM 접근  제어\n인프라  접근\n네트워크  보안\nSecurity Group\n포트 /IP 제어\nNetwork ACL\n서브넷  제어\n질문  2: 데이터  흐름  및  처리\n전체  데이터  플로우\n\n[Page 4]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n4 / 21\nDynamoDB번역  LLMSTT 서버캐시(Redis)웹서버클라이언트\nDynamoDB번역  LLMSTT 서버캐시(Redis)웹서버클라이언트\n1. 음성  입력  및  버퍼링\n2. STT 처리\n3. 원문  전달  ( 비동기 )\n4. 번역  처리  ( 병렬 )\nalt [ 확정  토큰  생성 ]\n[Zero-shot ( 짧은  단어 )]\nalt [ 캐시  존재 ]\n[ 캐시  미존재 ]\n5. 번역  전달\n6. 에러  처리\nalt [ 긴  문장  타임아웃  (2-3 초 )]\nPCM 버퍼  전송  ( 음성  스트림 )\n버퍼  적재\n( 언어 / 속도별  임계값 )\nPCM 버퍼  + 추론  언어코드\nVAD 분석  & 노멀라이즈\nSTT 추론  (0.2~0.8 초 )\n확정  토큰  생성\n확정  텍스트  + 확정  언어코드\n원문  텍스트  전송\nNLP 번역  가능성  검증\n캐시  조회  ( 원문  해시 )\n번역  결과  반환\n번역  요청\n번역  추론\n(20-80 자 : 0.3 초\n200 자 : 0.5 초 )\n번역  결과\n캐시  저장  (12h TTL)\n확정  토큰  없음\n짧은  단어  DB 조회\n번역  결과\n번역  텍스트  전송\n원문  + 번역  표출\n타임아웃\nSentence 분리  + SAT 의도  분할\n분할  문장  재요청  ( 오버랩  포함 )\n\n[Page 5]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n5 / 21\n처리  단계별  상세\n1. 입력  검증  및  전처리\nPass Fail\n임계값  이상 임계값  미만\n음성  버퍼  수신\n빈  사이즈  체크\n버퍼  적재 Skip\nSTT 서버  전달\nVAD 파형  분석\n노멀라이즈  적용 Skip\n확정  토큰  생성 ?\n\n[Page 6]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n6 / 21\nYes No\nYes No\n텍스트  추출 Skip\n확정  언어코드\n일치 ?\n웹서버  전달 Pass/Skip\n2. 병렬  처리  전략\n단계 처리  방식 응답  시간 비고\nSTT 처리 동기 0.2~0.8 초 화자  속도에  따라  변동\n원문  전달 비동기 즉시 클라이언트  우선  표출\n캐시  조회 비동기 <0.1 초 Redis 메모리  캐시\n번역  LLM비동기  병렬 0.3~0.5 초 20-200 자  기준\nDB 조회 비동기 <0.2 초 Zero-shot 폴백\n3. 에러  처리  메커니즘\n\n[Page 7]\nA",
                "ppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n7 / 21\n음성  없음 STT 서버  재시작\nYes\nNo\n번역  확정토큰  없음Zero-shot 긴  문장  타임아웃2-3 초 슬로우  리스폰스\n에러  발생\n에러  유형\n에러  미발생정상  Skip 프리웜  대기10-20 분\n선배포  후Health Check\n1 분  간격헬스  체크  Pass?\n로드밸런서  연동\nDynamoDB짧은  단어  조회 Sentence 분리\nSAT 의도  분할\n오버랩  포함재요청\nCloudWatch 탐지\nSlack 알림\n수동  검증\n질문  3: 프롬프트  인젝션  방어\n방어  전략  요약\n\n[Page 8]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n8 / 21\n프롬프트\n인젝션 방어\n입력 필터링화이트리스트 기반\n금지어 필터링별도 검증 규칙 없음\n시스템 설계\n생성형 콘텐츠 미생성\nSTT/ 번역 전용\n외부 프롬프트 미수용\n프롬프트 관리 내장 기본 프롬프트만 사용\n속도 최적화 우선 추가 프롬프트 미사용\n모니터링\n내부 테스트로 검증\n엔진 업데이트 시 검증\n별도 탐지 불필요\n보안  포지션\n항목 현황 위험도 근거\n입력  검증 화이트리스트  금지어  필터링 🟢  Low생성형  콘텐츠  미생성\n프롬프트  구조 내장  기본  프롬프트만  사용 🟢  Low외부  입력  미수용\n탐지  메커니즘 별도  탐지  없음",
                "🟢  Low공격  표면  없음\n테스트 내부  테스트로  검증 🟢  Low제한된  사용  사례\n결론 : STT/ 번역  전용  시스템으로  생성형  AI 의  프롬프트  인젝션  공격  표면이  존재하지  않음 .",
                "현재  방어  수준  적절 .\n질문  4: 데이터  프라이버시  및  보안\n데이터  생명주기  관리\n클라이언트  음성  입력\nPCM 버퍼\nSTT/ 번역  완료\n수집\n처리\n보관정책분기\n\n[Page 9]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n9 / 21\n고객  비공개  요청\n고객  공개  동의\n대화  종료\n캐시 / 로그 / 백업  포함  삭제\n번역  결과  캐싱\n배치  수집\n정규식  ( 전화번호 , 주소  등 )\n학습  플랫폼\n사람  검수\n파인튜닝\nISO27001 보안 PC 관리\n비공개\n공개\n즉시삭제\n2 주보관\n민감정보선별\n마스킹처리\n아케이드전달\n2 차검수\n학습데이터\n즉시  삭제  대상 :- 음성  데이터- STT 텍스트- 번역  결과- 캐시  (ElastiCache)- 로그  (CloudWatch)- 백업\n보관  기간 :- 번역  결과 : 2 주- 학습  데이터 : 영구(ISO27001 통제 )\n데이터  분류  및  보안  조치\n데이터  유형 저장  위치 보관  기간 암호화 접근  제어\n\n[Page 10]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n10 / 21\n데이터  유형 저장  위치 보관  기간 암호화 접근  제어\n음성  데이터  (PCM) 비공개 : 미저장\n공개 : 아케이드\n비공개 : 즉시  삭제\n공개 : 2 주 → 영구 N/A ISO27001 권한자\nSTT 텍스트 비공개 : 미저장\n공개 : 아케이드\n비공개 : 즉시  삭제\n공개 : 2 주 → 영구 N/A ISO27001 권한자\n번역  결과 ElastiCache 12 시간  (TTL) at rest (DynamoDB 설정 ) Private subnet\n짧은  단어  DB DynamoDB 영구 at rest (DynamoDB 암호화 ) IAM Role\n로그 EC2 파일시스템\nElasticsearch 정책별 Elasticsearch 무결성 인프라팀\n학습  데이터 보안  PC\nHuggingFace 영구 보안 PC, HF 암호화 ISO27001 권한자\n데이터  전송  암호화\n저장  데이터  암호화\nat rest ✅ at rest ✅ 물리적  ✅\nDynamoDB 암호화\nDynamoDB HuggingFace\nHF 암호화\n보안 PC\n하드디스크 /USB 2 중화\n전송  구간  암호화\nHTTPS ✅\n평문  ❌\nPrivate Subnet\n평문  ❌\nPrivate Subnet\n평문  ❌\nPrivate Subnet\n평문  ❌\nPrivate Subnet\n웹서버\n클라이언트\nSTT 서버 번역  LLM ElastiCache DynamoDB\n\n[Page 11]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n11 / 21\n보안  권고사항 :\n⚠  내부  Private Subnet 통신  구간  암호화  미적용  (TLS 추가  권장 )\n✅  외부  접점  ( 클라이언트 ↔ 웹서버 ) HTTPS 적용\n✅  저장  데이터  암호화  적용  (DynamoDB, HuggingFace)\n민감  정보  마스킹\n비공개\n공개\nYes\nNo\n데이터  수집 고객  요청\n즉시  삭제\n2 주  보관 데이터  선별ISO27001 권한자 민감  정보  포함 ?\n정규식  마스킹\n아케이드  전달\n마스킹  항목- 전화번호- 주소- 이메일- 카드번호\n2 주  후  자동  삭제\n2 차  사람  검수 학습  데이터\n데이터  삭제  프로세스\n삭제  유형 트리거 자동화 삭제  범위 검증\n즉시  삭제 대화  종료  ( 비공개 ) ✅  자동화 전체  ( 캐시 , 로그 , 백업  포함 ) ✅\n정기  삭제 TTL 만료  (12h, 2 주 ) ✅  자동화 캐시 , 마스킹  데이터 ✅\n사용자  요청 CS/ 영업팀  경유 ❌  수동 계약  조건  따름 ✅\n질문  5: 모델  보안  및  무결성\n모델  관리  생명주기\n학습  및  파인튜닝\nFail\n데이터  선별ISO27001 권한자\n데이터  수집아케이드  플랫폼\n2 차  사람  검수\n보안 PC파인튜닝  배치\n벤치마크WER/CER 검증\n\n[Page 12]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n12 / 21\n모니터",
                "링 운영  배포 버전  관리\n모델  저장  및  배포\nPass\nYes No\nHF Enterprise Hub다운로드  추적\n접근  로그언제 , 어디서 , 누가\nDocker 이미지  빌드\nEC2 배포\n배포  성공 ?\n프리웜  10-20 분 이전  Docker 이미지롤백\nHealth Check1 분  간격\n로드밸런서  연동\n버전  명명YYYYMMDD-Domain\n내부  문서변경  이력  관리\nPrivate HuggingFace모델  업로드\n자동  무결성  검증HF 서비스\n보안  스캔악성  모델  감지\n모델  서명Integrity Signature\n모델  접근  제어\n\n[Page 13]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n13 / 21\n권한  없음 권한  있음\nIP 불일치IP 일치\n모델  다운로드  요청\nPrivate HuggingFace\n접근  권한  확인\n접근  거부 IP 화이트리스트\n검증\n접근  거부\n로그  기록다운로드  허용\nEnterprise Hub\n다운로드  로그\n모니터링  대시보드\n- 언제\n- 어디서\n- 누가\nSecurity Alert\n비인가  접근  시도\n모델  무결성  검증\n\n[Page 14]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n14 / 21\n검증  단계 검증  방법 도구 / 서비스 주기검증  단계 검증  방법 도구 / 서비스 주기\n업로드  시 자동  무결성  검증 HuggingFace 서비스 매  업로드\n보안  스캔 악성  모델  감지 HF 자동  보안  스캔 매  업로드\n모델  서명 Integrity Signature HF 모델  서명 매  업로드\n성능  검증 WER/CER 벤치마크 자체  벤치마크셋 배포  전  필수\n배포  검증 Docker 이미지  무결성 Docker checksum 매  배포\n접근  추적 다운로드  로그  분석 HF Enterprise Hub 실시간\n모델  버전  관리  전략\n버전  명명  규칙 :\n{YYYYMMDD}-{Domain} \n예 : 20250815-Medical \n    20250901-Legal \n    20251001-General \n롤백  프로세스 :\n\n[Page 15]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n15 / 21\nDocker Registry로드밸런서EC2 인스턴스운영자\nDocker Registry로드밸런서EC2 인스턴스운영자\n배포  실패  또는  성능  저하  발생\n롤백  완료\n배포  중단  명령\nHealth Check Fail 응답\n해당  인스턴스  제외\n이전  버전  이미지  조회\n이전  Docker 이미지\n이전  이미지로  재실행\n컨테이너  재시작\n프리웜  (10-20 분 )\nHealth Check Pass\n트래픽  재연결\n학습  데이터  보안\n데이터  수집\n2 주  배치  수집\n아케이드  플랫폼\n내부  AWS?\n\n[Page 16]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n16 / 21\n데이터  보관\n학습  환경\n데이터  선별\nYes\n하드디스크  저장 USB 백업\n2 중화  무결성  검증\n보안 PC 전용\nISO27001 통제\n접근  권한\n열람권자만\n파인튜닝  배치\n자동화\n벤치마크  자동화\nWER/CER\nISO27001 권한자\n민감  정보  선별\n2 차  사람  검수\n아케이드\n평문  전송\n암호화  없음\n\n[Page 17]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n17 / 21\n학습  데이터  보안  통제 :\n✅  ISO 27001 준수 : 접근  권한  엄격  통제\n✅  물리적  보안 : 보안  PC 전용  환경\n✅  데이터  2 중화 : 하드디스크  + USB 백업\n✅  자동화 : 파인튜닝  및  벤치마크  자동화로  인적  오류  최소화\n⚠  내부  전송  암호화  미적용  ( 권장 )\n질문  6: 액세스  제어  및  인증\n인증  및  권한  관리  체계\n정기  검토권한  검토2주  간격 RBAC 적용\n권한  관리IAM 정책  관리인프라팀 개발  담당자별최소  권한  부여\nCTO보안  책임자Root 계정  관리\nAWS 리소스",
                "접근SSM 접근  권한관리자 EC2 인스턴스AWS ConfigureIAM Role리소스  접근최소  권한\n서비스  간  인증인증  없음Private Subnet인증  없음Private Subnet\nSTT 서버웹서버 번역  LLM\n사용자  인증HTTPS세션  인증클라이언트 ElastiCache세션  TTL 90 일\n백오피스 MFA 지원\n접근  제어  매트릭스\n접근  주체 대상  리소스 인증  방식 권한  수준 검토  주기\n클라이언트 웹서버  (Public) 세션  인증  (90 일  TTL) 사용자  권한 -\n백오피스 웹서버  (Public) 세션  인증  + MFA 관리자  권한 -\n웹서버 STT/ 번역  서버 없음  (Private Subnet) Full Access -\n관리자 EC2 인스턴스 SSM + IAM Role 최소  권한  (Least Privilege) 2주\n인프라팀 AWS 리소스 IAM + AWS Configure 부서별  최소  권한 2주\nCTO Root 계정 Root 계정  직접  관리 Full Access -\n개발자 AWS 리소스 IAM 담당  영역  최소  권한 2주\nISO 권한자 학습  데이터 ISO 27001 통제 읽기  전용 분기\nIAM 권한  구조\n\n[Page 18]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n18 / 21\nRoot 계정\nCTO 관리\n인프라팀\nIAM 관리자\n개발팀  A\n최소  권한\n개발팀  B\n최소  권한\n개발팀  C\n최소  권한\nEC2 인스턴스\n담당  영역만\nS3 버킷\n담당  영역만\nDynamoDB\n담당  영역만\n2 주  간격\n권한  검토\nRBAC 적용\n보안  원칙  적용 :\n✅  최소  권한  원칙  (Least Privilege): 모든  권한은  필요  최소한으로  부여\n✅  역할  기반  접근  제어  (RBAC): 역할별  권한  템플릿  관리\n✅  정기  권한  검토 : 2 주  간격으로  권한  적정성  검토\n✅  특권  계정  관리 : Root 계정은  CTO 가  직접  관리\n⚠  서비스  간  인증  부재 : Private Subnet 신뢰  기반  ( 서비스  인증  추가  권장 )\n📄  파일로  내보낸  질문  (7-10 번 )\n답변  대기  중인  질문\n질문  번호 제목 파일명 상태\n질문  7 로깅  및  모니터링 질문 7_ 로깅및모니터링 .md 📝  작성  대기\n질문  8 인시던트  대응 질문 8_ 인시던트대응 .md 📝  작성  대기\n질문  9 컴플라이언스  및  규정  준수 질문 9_ 컴플라이언스 .md 📝  작성  대기\n질문  10 향후  보안  계획 질문 10_ 향후보안계획 .md 📝  작성  대기\n질문  7 개요 : 로깅  및  모니터링\n로그  수집  및  저장  ( 접근 , 에러 , 보안  이벤트 )\n보안  이벤트  실시간  모니터링\n로그  분석  도구  및  프로세스\n감사  추적 (Audit Trail) 체계\n\n[Page 19]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n19 / 21\n질문  8 개요 : 인시던트  대응\n인시던트  대응  계획  및  팀  구성\n탐지  및  분류  메커니즘\n대응  및  복구  프로세스\n사후  분석  및  개선\n질문  9 개요 : 컴플라이언스\nISO 27001 및  기타  인증  현황\n개인정보  보호  법규  준수\n정기  감사  ( 내부 / 외부 , 모의해킹 )\n컴플라이언스  관리  체계\n질문  10 개요 : 향후  보안  계획\n단기  계획  (3-6 개월 )\n중장기  계획  (6-12 개월  이상 )\n예산  및  리소스  투자  계획\n기술  트렌드  및  신규  위협  대응\n📊  보안  현황  종합  평가\n강점  (Strengths)\n보안 강점\n네트워크 분리\nPrivate Subnet\nSTT/LLM 격리\n로드밸런서 분산\n데이터 보호\n비공개 즉시 삭제\n민감정보 마스킹\nISO27001 통제\n모델 보안\nPrivate HuggingFace\n접근 통제 버전 관리\n모니터링\nCloudWatch 실시간\nGuardDuty 위협 탐지\nSlack 알림\n핵심  강점 :\n\u0000. ✅",
                "명확한  네트워크  분리 : Public/Private Subnet 분리로  공격  표면  최소화\n\u0000. ✅  데이터  생명주기  관리 : 비공개  데이터  즉시  삭제로  프라이버시  보호\n\u0000. ✅  ISO 27001 준수 : 엄격한  접근  통제  및  데이터  관리\n\n[Page 20]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n20 / 21\n\u0000. ✅  모델  무결성 : HuggingFace Enterprise Hub 기반  체계적  관리\n\u0000. ✅  최소  권한  원칙 : IAM 기반  세분화된  권한  관리\n개선  권장  사항  (Recommendations)\n보안  개선  권장사항\n높음  우선순위 중간  우선순위 낮음  우선순위\n내부  통신  암호화웹서버 ↔ STT/LLMTLS 적용\n서비스  간  인증API Key or mTLS추가\n로깅  강화민감  데이터  접근Audit Trail 상세화\n침해  대응  훈련정기  시뮬레이션수행\n프롬프트  인젝션탐지  메커니즘고도화  검토\n우선순위 항목 현황 개선  방향 예상  효과\n🔴  높음 내부  통신  암호화 평문  (Private Subnet) TLS 적용 내부자  위협  완화\n🔴  높음 서비스  간  인증 없음 API Key or mTLS 서비스  스푸핑  방지\n🟡  중간 Audit Trail 강화 기본  로깅 상세  접근  로그 컴플라이언스  강화\n🟡  중간 침해  대응  훈련 문서화 정기  시뮬레이션 대응  시간  단축\n🟢  낮음 프롬프트  인젝션  탐지 없음 고도화  검토 생성형  전환  대비\n컴플라이언스  체크리스트\n항목 상태 근거\nISO 27001 ✅ ISO 27001 인증  보유\n개인정보보호법 ✅ 비공개  즉시  삭제 , 마스킹  처리\n최소  권한  원칙 ✅ IAM 기반  RBAC 적용\n데이터  암호화  (at rest) ✅ DynamoDB, HuggingFace\n데이터  암호화  (in transit) ⚠ HTTPS ( 외부 ), 평문  ( 내부 )\n로깅  및  모니터링 ✅ CloudWatch, Elasticsearch\n인시던트  대응  계획 ❓ 질문  8 답변  대기\n정기  보안  감사 ❓ 질문  9 답변  대기\n범례 :\n✅  완료 / 준수\n⚠  부분  준수  ( 개선  권장 )\n❓  확인  필요\n\n[Page 21]\nAppSec_ 질의응답 _ 진행현황 .md 2025-10-01\n21 / 21\n❌  미준수\n📋  다음  단계  (Next Steps)\n즉시  수행  (Immediate)\n\u0000. ✅  질문  1-6 답변  완료\n\u0000. 📝  질문  7-10 답변  파일  작성  ( 담당자  할당  필요 )\n\u0000. 📊  질문  7-10 답변  수집  후  최종  문서  통합\n단기  (1-2 주 )\n\u0000. 🔴  내부  통신  암호화  검토  및  계획  수립\n\u0000. 🔴  서비스  간  인증  메커니즘  설계\n\u0000. 🟡  Audit Trail 강화  방안  검토\n중기  (1-3 개월 )\n\u0000. 🟡  침해  대응  시뮬레이션  계획  수립\n\u0000. 📚  보안  정책  문서  업데이트\n\u0000. 🎓  보안  교육  프로그램  강화\n📞  연락처  및  담당자\n역할 담당자 연락처\n보안  책임자  (CISO) CTO -\n인프라팀  리더 - -\nISO 27001 담당자 - -\n개인정보  보호책임자  (CPO)- -\n인시던트  대응  리더 - -\n문서  이력 :\nv1.0 (2025-01-XX): 초안  작성  ( 질문  1-6 완료 )\nv2.0 ( 예정 ): 질문  7-10 통합  및  최종  검토"
            ]
        },
        {
            "filename": "iOS_Security_Testing_Environment.md",
            "total_characters": 23645,
            "total_chunks": 18,
            "chunks": [
                "# iOS 보안 테스트 환경 구성 가이드\n\n## 개요\n\n본 문서는 iOS 앱의 보안 테스트를 위한 종합적인 환경 구성 가이드입니다. OpenSW 도구들을 활용하여 정적 분석, 동적 분석, 침투 테스트를 수행할 수 있는 환경을 구축하는 방법을 설명합니다.\n\n## 목차\n\n1. [테스트 환경 개요](#테스트-환경-개요)\n2. [정적 분석 환경 구성](#정적-분석-환경-구성)\n3. [동적 분석 환경 구성](#동적-분석-환경-구성)\n4. [네트워크 분석 환경](#네트워크-분석-환경)\n5. [자동화 테스트 환경](#자동화-테스트-환경)\n6. [CI/CD 통합](#cicd-통합)\n\n---\n\n## 테스트 환경 개요\n\n### 필요 하드웨어/소프트웨어\n- **macOS**: Xcode 개발 환경\n- **iOS 디바이스**: 탈옥된 테스트 기기 (선택사항)\n- **네트워크 분석**: 프록시 서버 구성\n- **가상화**: Docker 컨테이너 환경\n\n### 테스트 유형별 도구 매트릭스\n\n| 테스트 유형 | 도구 | 용도 | 라이선스 |\n|------------|------|------|----------|\n| 정적 분석 | MobSF | 종합 분석 | LGPL-3.0 |\n| 정적 분석 | Semgrep | 코드 패턴 분석 | LGPL-2.1 |\n| 정적 분석 | SonarQube | 코드 품질 | LGPL-3.0 |\n| 동적 분석 | Frida | 런타임 분석 | wxWindows |\n| 동적 분석 | Objection | iOS 런타임 | GPL-3.0 |\n| 네트워크 | OWASP ZAP | 웹 취약점 | Apache-2.0 |\n| 네트워크 | mitmproxy | HTTP 프록시 | MIT |\n| 침투테스트 | Needle | iOS 전용 | BSD-3 |\n\n---\n\n## 정적 분석 환경 구성\n\n### 1. MobSF (Mobile Security Framework) 설치\n\n#### Docker 기반 설치\n```bash\n# MobSF Docker 이미지 실행\ndocker pull opensecurity/mobsf\ndocker run -it --rm -p 8000:8000 opensecurity/mobsf:latest\n\n# 또는 데이터 볼륨과 함께\ndocker run -it --rm \\\n    -p 8000:8000 \\\n    -v /path/to/uploads:/home/mobsf/Mobile-Security-Framework-MobSF/uploads \\\n    opensecurity/mobsf:latest\n```\n\n#### 소스 설치 (macOS)\n```bash\n# Python 가상환경 생성\npython3 -m venv mobsf-env\nsource mobsf-env/bin/activate\n\n# MobSF 클론 및 설치\ngit clone https://github.com/MobSF/Mobile-Security-Framework-MobSF.git\ncd Mobile-Security-Framework-MobSF\npip3 install -r requirements.txt\n\n# 실행\npython3 manage.py runserver 0.0.0.0:8000\n```\n\n#### MobSF 설정 파일\n```python\n# mobsf/settings.py 커스터마이징\nMOBSF_CONFIG = {\n    'ANALYZER': {\n        'ENABLED_SCANNERS': [\n            'static_analyzer',\n            'malware_analyzer',\n            'code_analyzer'\n        ],\n        'IOS_BINARY_ANALYSIS': True,\n        'BINARY_ANALYSIS_TIMEOUT': 300,\n    },\n    'SECURITY': {\n        'ENABLE_FRIDA': True,\n        'SSL_KILL_SWITCH': True,\n    }\n}\n```\n\n###",
                "2. Semgrep 설정\n\n#### 설치\n```bash\n# Homebrew 설치\nbrew install semgrep\n\n# 또는 pip 설치\npip3 install semgrep\n```\n\n#### iOS 전용 규칙 세트 구성\n```yaml\n# .semgrep.yml\nrules:\n  - id: hardcoded-api-key\n    pattern: |\n      let $API_KEY = \"$VALUE\"\n    message: \"하드코딩된 API 키 발견\"\n    languages: [swift]\n    severity: ERROR\n    \n  - id: insecure-keychain-access\n    pattern: |\n      kSecAttrAccessible$...kSecAttrAccessibleAlways...\n    message: \"안전하지 않은 Keychain 접근 설정\"\n    languages: [swift]\n    severity: WARNING\n    \n  - id: sql-injection-risk\n    pattern: |\n      \"SELECT * FROM $TABLE WHERE $FIELD = '\\($USER_INPUT)'\"\n    message: \"SQL 인젝션 위험\"\n    languages: [swift]\n    severity: ERROR\n\n  - id: tls-bypass\n    patterns:\n      - pattern: |\n          NSURLSessionConfiguration.default.urlCredentialStorage = nil\n      - pattern: |\n          session.dataTask(with: request) { data, response, error in\n            // TLS 인증서 검증 우회 코드\n          }\n    message: \"TLS 인증서 검증 우회 시도\"\n    languages: [swift]\n    severity: ERROR\n```\n\n#### Semgrep 실행 스크립트\n```bash\n#!/bin/bash\n# run_semgrep.sh\n\nPROJECT_PATH=\"$1\"\nOUTPUT_DIR=\"security_reports\"\n\nmkdir -p $OUTPUT_DIR\n\n# Swift 코드 스캔\nsemgrep --config=.semgrep.yml \\\n        --json \\\n        --output=$OUTPUT_DIR/semgrep_swift.json \\\n        $PROJECT_PATH\n\n# OWASP Top 10 규칙으로 스캔\nsemgrep --config=p/owasp-top-ten \\\n        --json \\\n        --output=$OUTPUT_DIR/semgrep_owasp.json \\\n        $PROJECT_PATH\n\n# 보고서 생성\nsemgrep --config=.semgrep.yml \\\n        --sarif \\\n        --output=$OUTPUT_DIR/semgrep_sarif.json \\\n        $PROJECT_PATH\n\necho \"Semgrep 분석 완료. 결과: $OUTPUT_DIR/\"\n```\n\n### 3. SonarQube 설정\n\n####",
                "Docker Compose 설정\n```yaml\n# docker-compose.sonar.yml\nversion: '3.8'\nservices:\n  sonarqube:\n    image: sonarqube:9-community\n    ports:\n      - \"9000:9000\"\n    environment:\n      - SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true\n    volumes:\n      - sonarqube_data:/opt/sonarqube/data\n      - sonarqube_logs:/opt/sonarqube/logs\n      - sonarqube_extensions:/opt/sonarqube/extensions\n    networks:\n      - sonarnet\n      \n  db:\n    image: postgres:13\n    environment:\n      POSTGRES_USER: sonar\n      POSTGRES_PASSWORD: sonar\n      POSTGRES_DB: sonar\n    volumes:\n      - postgresql_data:/var/lib/postgresql/data\n    networks:\n      - sonarnet\n\nvolumes:\n  sonarqube_data:\n  sonarqube_logs:\n  sonarqube_extensions:\n  postgresql_data:\n\nnetworks:\n  sonarnet:\n```\n\n#### SonarQube Swift 분석 설정\n```properties\n# sonar-project.properties\nsonar.projectKey=ios-security-test\nsonar.projectName=iOS Security Test\nsonar.projectVersion=1.0\n\nsonar.sources=.\nsonar.inclusions=**/*.swift\nsonar.exclusions=**/Pods/**,**/Build/**\n\nsonar.swift.coverage.reportPaths=sonarqube-generic-coverage.xml\nsonar.swift.swiftlint.reportPaths=swiftlint.xml\n\n# 보안 규칙 활성화\nsonar.security.hotspots=true\nsonar.security.review=true\n```\n\n---\n\n## 동적 분석 환경 구성\n\n### 1. Frida 환경 설정\n\n#### Frida Server 설치\n```bash\n# macOS에 Frida CLI 설치\npip3 install frida-tools\n\n# iOS 디바이스에 Frida Server 설치 (탈옥된 기기)\n# Cydia에서 https://build.frida.re/ 추가 후\n# Frida 패키지 설치\n```\n\n#### Frida 스크립트 예제\n```javascript\n// frida_keychain_hook.js\nJava.perform(function() {\n    var SecItemCopyMatching = new NativeFunction(\n        Module.findExportByName(\"Security\", \"SecItemCopyMatching\"),\n        'int', ['pointer', 'pointer']\n    );\n    \n    Interceptor.replace(SecItemCopyMatching, new NativeCallback(function(query, result) {\n        console.log(\"[+] SecItemCopyMatching 호출됨\");\n        console.log(\"[+]",
                "Query: \" + ObjC.Object(query).toString());\n        \n        var ret = SecItemCopyMatching(query, result);\n        console.log(\"[+] 반환값: \" + ret);\n        \n        return ret;\n    }, 'int', ['pointer', 'pointer']));\n    \n    // URL 요청 후킹\n    var NSURLRequest = ObjC.classes.NSURLRequest;\n    var originalRequestWithURL = NSURLRequest[\"- requestWithURL:\"];\n    \n    Interceptor.attach(originalRequestWithURL.implementation, {\n        onEnter: function(args) {\n            var url = new ObjC.Object(args[2]);\n            console.log(\"[+] URL 요청: \" + url.absoluteString());\n        }\n    });\n});\n```\n\n#### Frida 실행 스크립트\n```bash\n#!/bin/bash\n# run_frida.sh\n\nDEVICE_ID=\"$1\"\nAPP_BUNDLE_ID=\"$2\"\nSCRIPT_FILE=\"$3\"\n\n# 기기 연결 확인\nfrida-ls-devices\n\n# 앱에 스크립트 주입\nfrida -U -l $SCRIPT_FILE $APP_BUNDLE_ID\n\n# 또는 프로세스 PID로 연결\n# frida -U -p <PID> -l $SCRIPT_FILE\n```\n\n### 2. Objection 설정\n\n#### 설치 및 설정\n```bash\n# Objection 설치\npip3 install objection\n\n# iOS 앱 분석 시작\nobjection -g \"com.yourapp.bundleid\" explore\n\n# 또는 USB 연결된 기기\nobjection --gadget \"YourApp\" explore\n```\n\n####",
                "Objection 주요 명령어 스크립트\n```bash\n#!/bin/bash\n# objection_commands.sh\n\nAPP_BUNDLE=\"com.yourapp.bundleid\"\n\nobjection -g $APP_BUNDLE explore <<EOF\n# Keychain 분석\nios keychain dump\nios keychain dump --json keychain_dump.json\n\n# 쿠키 분석\nios cookies get --json cookies.json\n\n# 파일 시스템 탐색\nls /var/mobile/Containers/Data/Application/\n\n# 바이너리 정보\nios info binary\n\n# SSL Kill Switch\nios sslkill disable\n\n# 메모리 덤프\nmemory dump all memory_dump.bin\n\n# 클래스 정보\nios hooking list classes\nios hooking list class_methods \"YourClass\"\n\n# 메소드 후킹\nios hooking watch method \"-[YourClass sensitiveMethod:]\"\n\nquit\nEOF\n```\n\n### 3. 런타임 분석 자동화\n\n#### Python 기반 분석 스크립트\n```python\n#!/usr/bin/env python3\n# ios_runtime_analyzer.py\n\nimport frida\nimport json\nimport time\nimport logging\n\nclass iOSRuntimeAnalyzer:\n    def __init__(self, device_id=None, bundle_id=None):\n        self.device = frida.get_usb_device() if device_id is None else frida.get_device(device_id)\n        self.bundle_id = bundle_id\n        self.session = None\n        \n        # 로깅 설정\n        logging.basicConfig(level=logging.INFO)\n        self.logger = logging.getLogger(__name__)\n        \n    def connect_to_app(self):\n        \"\"\"앱에 연결\"\"\"\n        try:\n            self.session = self.device.attach(self.bundle_id)\n            self.logger.info(f\"앱에 연결됨: {self.bundle_id}\")\n            return True\n        except Exception as e:\n            self.logger.error(f\"연결 실패: {e}\")\n            return False\n    \n    def load_script(self, script_path):\n        \"\"\"Frida 스크립트 로드\"\"\"\n        with open(script_path, 'r') as f:\n            script_code = f.read()\n        \n        script = self.session.create_script(script_code)\n        script.on('message', self._on_message)\n        script.load()\n        \n        return script\n    \n    def _on_message(self, message, data):\n        \"\"\"메시지 핸들러\"\"\"\n        if message['type'] = = 'send':\n            self.logger.info(f\"[Frida] {message['payload']}\")\n        elif message['type'] =",
                "= 'error':\n            self.logger.error(f\"[Frida Error] {message['description']}\")\n    \n    def perform_security_analysis(self, duration=300):\n        \"\"\"보안 분석 수행\"\"\"\n        # 네트워크 트래픽 모니터링\n        network_script = self.load_script('scripts/network_monitor.js')\n        \n        # Keychain 접근 모니터링\n        keychain_script = self.load_script('scripts/keychain_monitor.js')\n        \n        # 암호화 API 모니터링\n        crypto_script = self.load_script('scripts/crypto_monitor.js')\n        \n        self.logger.info(f\"{duration}초 동안 분석 시작...\")\n        time.sleep(duration)\n        \n        return {\n            'network_calls': network_script.exports.get_network_calls(),\n            'keychain_accesses': keychain_script.exports.get_keychain_accesses(),\n            'crypto_operations': crypto_script.exports.get_crypto_operations()\n        }\n\n# 사용 예\nif __name__ == \"__main__\":\n    analyzer = iOSRuntimeAnalyzer(bundle_id=\"com.yourapp.bundleid\")\n    if analyzer.connect_to_app():\n        results = analyzer.perform_security_analysis(300)\n        \n        # 결과 저장\n        with open('runtime_analysis_results.json', 'w') as f:\n            json.dump(results, f, indent=2)\n```\n\n---\n\n## 네트워크 분석 환경\n\n### 1. OWASP ZAP 설정\n\n####",
                "Docker 실행\n```bash\n# ZAP 컨테이너 실행\ndocker run -t -p 8080:8080 \\\n    -v $(pwd)/zap_reports:/zap/wrk/:rw \\\n    -i zaproxy/zap-stable zap.sh \\\n    -daemon -host 0.0.0.0 -port 8080 \\\n    -config api.addrs.addr.name=.* \\\n    -config api.addrs.addr.regex=true\n```\n\n#### iOS 기기 프록시 설정 스크립트\n```python\n#!/usr/bin/env python3\n# zap_ios_proxy.py\n\nimport time\nimport requests\nfrom zapv2 import ZAPv2\n\nclass iOSZAPProxy:\n    def __init__(self, zap_host='localhost', zap_port=8080):\n        self.zap = ZAPv2(proxies={\n            'http': f'http://{zap_host}:{zap_port}',\n            'https': f'https://{zap_host}:{zap_port}'\n        })\n        \n    def setup_ios_proxy(self):\n        \"\"\"iOS 기기용 프록시 설정\"\"\"\n        # SSL 인증서 생성\n        cert = self.zap.core.rootcert()\n        with open('zap_root_ca.crt', 'wb') as f:\n            f.write(cert)\n        \n        print(\"1. iOS 기기 설정 > Wi-Fi > 네트워크 정보 > HTTP 프록시\")\n        print(\"2. 수동 설정: 서버=<MAC_IP>, 포트=8080\")\n        print(\"3. Safari에서 <MAC_IP>:8080 접속하여 CA 인증서 다운로드\")\n        print(\"4. 설정 > 일반 > VPN 및 기기 관리 > 인증서 설치\")\n        print(\"5.",
                "설정 > 일반 > 정보 > 인증서 신뢰 설정에서 ZAP 인증서 신뢰\")\n        \n        input(\"프록시 설정 완료 후 Enter를 누르세요...\")\n        \n    def start_passive_scan(self, target_url):\n        \"\"\"패시브 스캔 시작\"\"\"\n        print(f\"패시브 스캔 시작: {target_url}\")\n        self.zap.spider.scan(target_url)\n        \n        while int(self.zap.spider.status()) < 100:\n            print(f\"Spider 진행률: {self.zap.spider.status()}%\")\n            time.sleep(2)\n            \n    def start_active_scan(self, target_url):\n        \"\"\"액티브 스캔 시작\"\"\"\n        print(f\"액티브 스캔 시작: {target_url}\")\n        self.zap.ascan.scan(target_url)\n        \n        while int(self.zap.ascan.status()) < 100:\n            print(f\"Active Scan 진행률: {self.zap.ascan.status()}%\")\n            time.sleep(10)\n            \n    def generate_report(self, format='html'):\n        \"\"\"리포트 생성\"\"\"\n        if format == 'html':\n            return self.zap.core.htmlreport()\n        elif format == 'xml':\n            return self.zap.core.xmlreport()\n        elif format == 'json':\n            return self.zap.core.jsonreport()\n\n# 사용 예\nif __name__ == \"__main__\":\n    proxy = iOSZAPProxy()\n    proxy.setup_ios_proxy()\n    \n    target = \"https://your-api-endpoint.com\"\n    proxy.start_passive_scan(target)\n    proxy.start_active_scan(target)\n    \n    # HTML 리포트 생성\n    report = proxy.generate_report('html')\n    with open('zap_security_report.html', 'w') as f:\n        f.write(report)\n```\n\n### 2. mitmproxy 설정\n\n#### 설치 및 기본 설정\n```bash\n# mitmproxy 설치\npip3 install mitmproxy\n\n# iOS용 인증서 설정\nmitmdump --set confdir=~/.mitmproxy\n```\n\n#### 커스텀 스크립트\n```python\n# mitmproxy_ios_monitor.py\nimport json\nfrom mitmproxy import http, ctx\n\nclass iOSSecurityMonitor:\n    def __init__(self):\n        self.api_calls = []\n        self.sensitive_data = []\n        \n    def request(self, flow: http.HTTPFlow) -> None:\n        \"\"\"요청 분석\"\"\"\n        # API 키 검출\n        for header_name, header_value in flow.request.headers.items():\n            if 'api' in header_name.lower() and 'key' in header_name.lower():\n                sel",
                "f.sensitive_data.append({\n                    'type': 'api_key_in_header',\n                    'url': flow.request.pretty_url,\n                    'header': header_name,\n                    'value': header_value[:10] + \"...\"\n                })\n        \n        # URL에서 민감정보 검출\n        if any(param in flow.request.query for param in ['password', 'token', 'key']):\n            self.sensitive_data.append({\n                'type': 'sensitive_param_in_url',\n                'url': flow.request.pretty_url,\n                'params': list(flow.request.query.keys())\n            })\n    \n    def response(self, flow: http.HTTPFlow) -> None:\n        \"\"\"응답 분석\"\"\"\n        if flow.response.status_code == 200:\n            try:\n                content = json.loads(flow.response.text)\n                \n                # 응답에서 토큰 검출\n                if 'token' in content or 'access_token' in content:\n                    self.api_calls.append({\n                        'url': flow.request.pretty_url,\n                        'method': flow.request.method,\n                        'has_token': True,\n                        'response_size': len(flow.response.content)\n                    })\n            except:\n                pass\n    \n    def done(self):\n        \"\"\"분석 완료 시 리포트 생성\"\"\"\n        report = {\n            'api_calls': self.api_calls,\n            'sensitive_data_detected': self.sensitive_data,\n            'total_requests': len(self.api_calls)\n        }\n        \n        with open('mitmproxy_security_report.json', 'w') as f:\n            json.dump(report, f, indent=2)\n        \n        ctx.log.info(f\"보안 분석 완료.",
                "민감정보 {len(self.sensitive_data)}건 발견\")\n\naddons = [iOSSecurityMonitor()]\n```\n\n#### 실행 스크립트\n```bash\n#!/bin/bash\n# run_mitmproxy.sh\n\n# iOS 보안 모니터링 시작\nmitmdump -s mitmproxy_ios_monitor.py \\\n         --set confdir=~/.mitmproxy \\\n         --set web_host=0.0.0.0 \\\n         --set web_port=8081 \\\n         --ssl-insecure\n\necho \"mitmproxy가 시작되었습니다.\"\necho \"iOS 기기에서 프록시 설정: <MAC_IP>:8080\"\necho \"웹 인터페이스: http://localhost:8081\"\n```\n\n---\n\n## 자동화 테스트 환경\n\n###",
                "1. GitHub Actions 워크플로우\n\n```yaml\n# .github/workflows/ios-security-test.yml\nname: iOS Security Testing\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  security-scan:\n    runs-on: macos-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Setup Xcode\n      uses: maxim-lobanov/setup-xcode@v1\n      with:\n        xcode-version: latest-stable\n    \n    - name: Install Dependencies\n      run: |\n        pip3 install semgrep\n        brew install sonar-scanner\n        \n    - name: Build iOS App\n      run: |\n        xcodebuild -workspace YourApp.xcworkspace \\\n                   -scheme YourApp \\\n                   -configuration Release \\\n                   -archivePath YourApp.xcarchive \\\n                   archive\n                   \n        xcodebuild -exportArchive \\\n                   -archivePath YourApp.xcarchive \\\n                   -exportPath ./build \\\n                   -exportOptionsPlist ExportOptions.plist\n    \n    - name: Static Analysis with Semgrep\n      run: |\n        mkdir -p security-reports\n        semgrep --config=.semgrep.yml \\\n                --json \\\n                --output=security-reports/semgrep.json \\\n                .\n                \n    - name: Security Scan with MobSF\n      run: |\n        docker run --rm \\\n          -v $(pwd)/build:/app:ro \\\n          -v $(pwd)/security-reports:/reports:rw \\\n          opensecurity/mobsf:latest \\\n          python3 /home/mobsf/Mobile-Security-Framework-MobSF/manage.py \\\n          scan /app/YourApp.ipa\n    \n    - name: Upload Security Reports\n      uses: actions/upload-artifact@v3\n      with:\n        name: security-reports\n        path: security-reports/\n    \n    - name: Comment PR with Results\n      if: github.event_name == 'pull_request'\n      uses: actions/github-script@v6\n      with:\n        script: |\n          const fs = require('fs');\n          const report = JSON.parse(fs.readFileSync('security-reports/semgrep.json'));\n          const high_issu",
                "es = report.results.filter(r => r.extra.severity ==",
                "= 'ERROR');\n          \n          github.rest.issues.createComment({\n            issue_number: context.issue.number,\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            body: `🔒 보안 스캔 결과: ${high_issues.length}개의 높은 위험도 이슈 발견`\n          });\n```\n\n### 2. 로컬 자동화 스크립트\n\n```bash\n#!/bin/bash\n# automated_ios_security_test.sh\n\nPROJECT_PATH=\"$1\"\nSCHEME=\"$2\"\nREPORT_DIR=\"security_reports_$(date +%Y%m%d_%H%M%S)\"\n\necho \"iOS 보안 테스트 자동화 시작...\"\necho \"프로젝트: $PROJECT_PATH\"\necho \"스킴: $SCHEME\"\n\n# 리포트 디렉토리 생성\nmkdir -p $REPORT_DIR\n\n# 1. 코드 빌드\necho \"1단계: 앱 빌드 중...\"\nxcodebuild -workspace \"$PROJECT_PATH.xcworkspace\" \\\n           -scheme \"$SCHEME\" \\\n           -configuration Release \\\n           -archivePath ./build/$SCHEME.xcarchive \\\n           archive\n\nif [ $? -ne 0 ]; then\n    echo \"빌드 실패. 테스트를 중단합니다.\"\n    exit 1\nfi\n\n# 2. IPA 내보내기\nxcodebuild -exportArchive \\\n           -archivePath ./build/$SCHEME.xcarchive \\\n           -exportPath ./build \\\n           -exportOptionsPlist ExportOptions.plist\n\n# 3. 정적 분석\necho \"2단계: 정적 분석 시작...\"\n\n# Semgrep 분석\nsemgrep --config=.semgrep.yml \\\n        --json \\\n        --output=$REPORT_DIR/semgrep.json \\\n        $PROJECT_PATH\n\n# Swift Lint 분석\nswiftlint --reporter json > $REPORT_DIR/swiftlint.json\n\n# 4. MobSF 분석\necho \"3단계: MobSF 분석 시작...\"\ndocker run --rm \\\n    -v $(pwd)/build:/app:ro \\\n    -v $(pwd)/$REPORT_DIR:/reports:rw \\\n    opensecurity/mobsf:latest \\\n    python3 manage.py scan_ipa /app/$SCHEME.ipa\n\n# 5. 보고서 생성\necho \"4단계: 종합 보고서 생성...\"\npython3 scripts/generate_security_report.py \\\n    --semgrep $REPORT_DIR/semgrep.json \\\n    --mobsf $REPORT_DIR/mobsf.json \\\n    --swiftlint $REPORT_DIR/swiftlint.json \\\n    --output $REPORT_DIR/comprehensive_report.html\n\necho \"보안 테스트 완료. 결과: $REPORT_DIR/\"\necho \"종합 보고서: $REPORT_DIR/comprehensive_report.html\"\n\n# 6. 결과 요약 출력\npython3 -c \"\nimport json\nwith open('$REPORT_DIR/semgrep.json') as f:\n    data = json.load(f)\n    high = len([r for r in data['results'] if r['extra']['severity'] =",
                "= 'ERROR'])\n    medium = len([r for r in data['results'] if r['extra']['severity'] = = 'WARNING'])\n    print(f'보안 이슈 요약: 높음 {high}개, 중간 {medium}개')\n\"\n```\n\n---\n\n## CI/CD 통합\n\n###",
                "1. Jenkins Pipeline\n\n```groovy\n// Jenkinsfile\npipeline {\n    agent {\n        label 'macos'\n    }\n    \n    environment {\n        SCHEME = 'YourApp'\n        WORKSPACE_PATH = 'YourApp.xcworkspace'\n    }\n    \n    stages {\n        stage('Checkout') {\n            steps {\n                checkout scm\n            }\n        }\n        \n        stage('Build') {\n            steps {\n                sh '''\n                    xcodebuild -workspace ${WORKSPACE_PATH} \\\n                               -scheme ${SCHEME} \\\n                               -configuration Release \\\n                               -archivePath ./build/${SCHEME}.xcarchive \\\n                               archive\n                '''\n            }\n        }\n        \n        stage('Security Scan') {\n            parallel {\n                stage('Static Analysis') {\n                    steps {\n                        sh '''\n                            mkdir -p security-reports\n                            semgrep --config=.semgrep.yml \\\n                                    --json \\\n                                    --output=security-reports/semgrep.json \\\n                                    .\n                        '''\n                    }\n                }\n                \n                stage('MobSF Analysis') {\n                    steps {\n                        sh '''\n                            docker run --rm \\\n                                -v $(pwd)/build:/app:ro \\\n                                -v $(pwd)/security-reports:/reports:rw \\\n                                opensecurity/mobsf:latest\n                        '''\n                    }\n                }\n            }\n        }\n        \n        stage('Report Generation') {\n            steps {\n                sh 'python3 scripts/generate_security_report.py'\n                publishHTML([\n                    allowMissing: false,\n                    alwaysLinkToLastBuild: true,\n                    keepAll: true,\n                    reportDir: 'securi",
                "ty-reports',\n                    reportFiles: 'comprehensive_report.html',\n                    reportName: 'Security Report'\n                ])\n            }\n        }\n    }\n    \n    post {\n        always {\n            archiveArtifacts artifacts: 'security-reports/**/*', allowEmptyArchive: true\n        }\n        failure {\n            emailext(\n                subject: \"iOS Security Test Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}\",\n                body: \"보안 테스트가 실패했습니다.",
                "Jenkins에서 상세 내용을 확인하세요.\",\n                to: \"${env.CHANGE_AUTHOR_EMAIL}\"\n            )\n        }\n    }\n}\n```\n\n### 2. GitLab CI/CD\n\n```yaml\n# .gitlab-ci.yml\nstages:\n  - build\n  - security-test\n  - report\n\nvariables:\n  SCHEME: \"YourApp\"\n  WORKSPACE: \"YourApp.xcworkspace\"\n\nbefore_script:\n  - pip3 install semgrep\n\nbuild_ios:\n  stage: build\n  script:\n    - xcodebuild -workspace $WORKSPACE\n                 -scheme $SCHEME\n                 -configuration Release\n                 -archivePath ./build/$SCHEME.xcarchive\n                 archive\n  artifacts:\n    paths:\n      - build/\n    expire_in: 1 hour\n\nstatic_analysis:\n  stage: security-test\n  script:\n    - mkdir -p security-reports\n    - semgrep --config=.semgrep.yml\n              --json\n              --output=security-reports/semgrep.json\n              .\n  artifacts:\n    reports:\n      junit: security-reports/semgrep.json\n    paths:\n      - security-reports/\n    expire_in: 1 week\n\nmobsf_analysis:\n  stage: security-test\n  services:\n    - docker:dind\n  script:\n    - docker run --rm\n        -v $(pwd)/build:/app:ro\n        -v $(pwd)/security-reports:/reports:rw\n        opensecurity/mobsf:latest\n  artifacts:\n    paths:\n      - security-reports/\n    expire_in: 1 week\n\ngenerate_report:\n  stage: report\n  script:\n    - python3 scripts/generate_security_report.py\n        --semgrep security-reports/semgrep.json\n        --mobsf security-reports/mobsf.json\n        --output security-reports/comprehensive_report.html\n  artifacts:\n    reports:\n      junit: security-reports/junit.xml\n    paths:\n      - security-reports/comprehensive_report.html\n  coverage: '/Coverage: \\d+\\.\\d+%/'\n```\n\n---\n\n## 추가 도구 및 리소스\n\n### 유용한 OpenSW 도구들\n\n1. **class-dump**: Objective-C 클래스 정보 추출\n2. * *otool**: 마크 오브젝트 파일 분석\n3. * *Hopper Disassembler**: 바이너리 분석 (Community Edition)\n4. * *iOS App Signer**: 임시 앱 서명\n5. *",
                "*Keychain Dumper**: Keychain 데이터 덤프\n\n### 참고 문서\n\n- [OWASP Mobile Security Testing Guide](https://owasp.org/www-project-mobile-security-testing-guide/)\n- [iOS Application Security](https://github.com/OWASP/owasp-mstg)\n- [Frida Documentation](https://frida.re/docs/)\n- [MobSF Documentation](https://mobsf.github.io/docs/)\n\n이 가이드를 통해 iOS 앱의 포괄적인 보안 테스트 환경을 구축하고, 지속적인 보안 검증을 자동화할 수 있습니다."
            ]
        }
    ],
    "skipped": []
}